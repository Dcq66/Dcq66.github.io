<html>

<head>
    <meta charset="utf-8">
    
    <title>小戴的学习日记</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/tagplugins.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="小戴的学习日记" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Dcq66.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">小戴的学习日记</h1>
    <p class="lead blog-description">Dcq66.github.io</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/25/Css/Css17/">Css17</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-25
        
    </p>

    

    <!-- Content -->
    <p>像素</p>
<pre><code>* 屏幕是由一个一个发光的小点构成，这一个一个的小点就是像素
    分辨率：1920 × 1080 说的就是屏幕中小点的数量
* 在前端开发中像素要分为两种情况讨论，CSS像素和物理像素
    - CSS像素，编写网页时我们所用的像素就是CSS像素，浏览器在显示网页时，
        需要将CSS像素转换为物理像素然后再呈现，一个CSS像素由几个物理像素显示由浏览器决定
            默认情况下在PC端，一个CSS像素 = 一个物理像素</code></pre>
<p>视口（viewport）</p>
<pre><code>* 视口就是屏幕中用来显示网页的区域
* 可以通过查看视口的大小来观察CSS像素和物理像素的比值
* 默认情况下：
    - 视口宽度 1920px （CSS像素）
            1920px （物理像素）
            此时，CSS像素和物理像素的比值为1 ：1
* 放大两倍的情况下：
    - 视口宽度 960px （CSS像素）
            1920px （物理像素）
            此时，CSS像素和物理像素的比值为1 ：2
    - 我们可以通过改变视口的大小来改变CSS像素和物理像素的比值
* 在不同的屏幕中，单位像素的大小是不一样的，单位像素越小屏幕越清晰
    24寸 1920 × 1080
    iPhone6 4.7寸 750 × 1334
    https://material.io/resources/devices/ （查询各种手机像素比的网站）
    - 默认情况下，移动端的网页都会将视口设置为980像素（CSS像素）
        以确保pc端网页可以在移动端正常访问，但如果网页的宽度超过980
            移动端的浏览器会自动对网页进行缩放以完整显示网页，但往往不会有一个好的用户体验
                为了解决这个问题，大部分网站都会专门为了移动端设计网页</code></pre>
<p>移动端的设计</p>
<pre><code>* 使用媒体查询
    - 语法：@media 媒体类型&#123;&#125;
    - 媒体类型：
        - all 所有设备
        - print 打印设备
        - screen 带屏幕的设备
        - speech 屏幕阅读器
    - 可以在媒体类型前添加一个only，表示只有
        only的使用主要是为了兼容一些老版本浏览器
* 响应式布局
    - 网页可以根据不同的设备或窗口大小显示出不同的效果
    - 使用响应式布局可以使一个网页适用于所有设备
    - 响应式布局的关键就是媒体查询
        通过媒体查询可以为不同的设备或设备不同的状态来分别设置样式
* 媒体特性
    - width 视口宽度
    - height 视口高度
    - min-width 视口的最小宽度（视口大于指定宽度时生效）
    - max-width 视口的最大宽度（视口小于指定宽度时生效）
* 断点：样式切换的分界点称之为断点
* 视口大小
    - 小于768（CSS像素）超小屏幕 max-width=768px
    - 大于768（CSS像素）小屏幕   min-width=768px
    - 大于992（CSS像素）中型屏幕   min-width=992px
    - 大于1200（CSS像素）小屏幕   min-width=1200px
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@media not screen and (min-width:500px) and (max-width:700px)&#123;</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color:red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--</span><br><span class="line"> 该样式意思为带屏幕设备除了宽度在500px和700px之间时body为红色</span><br><span class="line">    not 除了</span><br><span class="line">    and 且</span><br><span class="line">    ,   或</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/25/Css/Css16/">Css16</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-25
        
    </p>

    

    <!-- Content -->
    <p>flex</p>
<pre><code>* flex
    - 将元素的display属性设置为flex，则该元素为弹性容器，该元素的子元素为弹性元素
    - flex还可以作为属性来使用，它可以设置所有弹性元素的三个样式
        - flex 增长 缩减 基础
            - initial “flex：0 1 auto”（只缩减不增长）
            - auto “flex：1 1 auto”（既增长也缩减）
            - none “flex：0 0 auto”（弹性元素没有弹性）
* 主轴：弹性元素的排列方式为主轴
* 侧轴：与主轴垂直方向的为侧轴
* 属性：
    - flex-direction 指定容器中弹性元素的排列方式
        可选值：
            - row 默认值，弹性元素在容器中水平排列（自左向右）
                - 主轴 自左向右
            - row-reverse 弹性元素在容器中反向水平排列（自右向左）
                - 主轴 自右向左
            - column 弹性元素在容器中纵向排列（自上向下）
                - 主轴 自上向下
            - column 弹性元素在容器中反向纵向排列（自下向上）
                - 主轴 自下向上
    - flex-grow 指定弹性元素的伸展系数
        - 当父元素有多余空间时，子元素如何伸展
        - 父元素的剩余空间会按照比例分配
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex-grow:1;</span><br><span class="line">&lt;!-- 该弹性元素在父元素的剩余空间分配中占比例中的一份 --&gt;</span><br></pre></td></tr></table></figure>
    - flex-shrink 指定弹性元素的收缩系数
        - 当父元素的空间不足以收纳所有子元素时对子元素进行收缩
        - 子元素越大则该子元素收缩的越大
    - flex-wrap 设置弹性元素是否在弹性容器中自动换行
        可选值：
            - nowrap 默认值，元素不会自动换行
            - wrap 元素会沿着侧轴方向自动换行
            - wrap-reserve 元素会沿着侧轴反方向自动换行
    - flex-flow wrap和direction的简写属性，可同时设置这两个属性
    - flex-basis 指定的是元素在主轴上的基础长度
        - 如果主轴是横向的，则该值指定的是元素的宽度
        - 如果主轴是纵向的，则该值指定的是元素的高度
        - 默认值是auto，表示参考元素自身的高度或宽度
        - 如果传递了一个具体的数值，则以该值为准
    - order 决定弹性元素的排列顺序
    - justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列）
        可选值：
            - flex-start 元素沿着主轴起边排列
            - flex-end 元素沿着主轴终边排列
            - center 元素沿着主轴居中排列
            - space-around 空白均匀分到元素两侧
            - space-between 空白均匀分到元素间
            - space-evenly 空白均匀分到元素的单侧
    - align-items 元素在侧轴上如何对齐
        可选值：
            - stretch 默认值，将元素的长度设置为相同的值
            - flex-start 元素不会拉伸，沿着侧轴起边对齐
            - flex-end 元素不会拉伸，沿着侧轴终边对齐
            - center 居中对齐
            - baseline 基线对齐
    - align-content 侧轴空白空间的分布，可选值与justify-content一样
    - align-self 用来覆盖当前当前弹性元素上的align-items</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/25/Css/Css15/">Css15</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-25
        
    </p>

    

    <!-- Content -->
    <p>变形</p>
<pre><code>* 变形就是指通过css来改变元素的形状或位置
    - 变形不会影响到页面的布局
    - transform用来设置元素的变形效果
        - 平移：
            - translateX() 沿着X轴方向平移
            - translateY() 沿着Y轴方向平移
            - translateZ() 沿着Z轴方向平移
                - Z轴平移，调整元素在Z轴上的位置，由于其属于立体效果（近大远小），
                    默认情况下网页是不支持透视的，如果想要看见效果，必须设置网页的视距
                        即perspective属性，将其设置在html（根元素）的样式中
            - 平移元素，百分比是相对于自身计算的
        - 旋转：通过旋转可以使元素沿着x、y或z轴旋转指定的角度
            - rotateX() 沿着X轴旋转
            - rotateY() 沿着Y轴旋转
            - rotateZ() 沿着Z轴旋转
            - 旋转时还可以通过backface-visibility属性来设置是否显示元素的背面
        - 3d变形效果
            - 若想要看到所设置的立体动态效果，需通过transform-style属性来设置其3d效果
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform-style:preserve-3d;</span><br></pre></td></tr></table></figure>
        - transform-origin（变形原点）
            - 默认值为center
            - 可自定设置原点
        - 对元素进行缩放的函数（倍数缩放）
            - scale() 双方向的缩放
            - scaleX() 水平方向的缩放
            - scaleY() 垂直方向的缩放</code></pre>
<p>变量</p>
<pre><code>* css也支持变量的设置
    - 变量的设置规范
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--color:red;</span><br></pre></td></tr></table></figure>
    - 引用变量时的语法规范
     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color:var(--color);</span><br></pre></td></tr></table></figure>
    - 设置变量可以帮助我们在做代码量较多的项目修改时更方便</code></pre>
<p>less</p>
<pre><code>* less是一门css的预处理语言
    - less是一个css的增强版，通过该预处理语言我们可以编写更少的代码实现更强大的样式</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/21/JavaScript/JavaScript06/">JavaScript06</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-21
        
    </p>

    

    <!-- Content -->
    <p>数组</p>
<pre><code>* 数组（Array）
    - 数组也是一个对象
    - 它和普通对象功能类似，也是用来储存一些值的
    - 不同的是普通对象使用的是字符串作为属性名的
        而数组是使用数字来作为索引操作元素的
    - 索引：从0开始的整数就是索引
    - 数组的存储性能比普通对象要好
* 创建数组对象
    - 使用构造函数创建数组
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;new Array();</span><br></pre></td></tr></table></figure>
    - 使用typeof检查一个数组时会返回object
    - 如果读取不存在的索引，不会报错而是返回undefined
    - 获取数组的长度
        - 可以使用length属性来获取数组长度
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;new Array();</span><br><span class="line">console.log(arr.length);</span><br></pre></td></tr></table></figure>
        对于连续的数组，使用length可以获取到数组的长度（元素的个数）
            对于非连续的数组，使用length可以获取到数组的最大索引+1
                尽量不要创建非连续的数组
    - 修改length
        - 如果修改的length大于原长度，则多出部分会空出来
        - 如果修改的length小于原长度，则多出的元素会被删除
    - 使用字面量创建数组
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[];</span><br></pre></td></tr></table></figure>
    - 使用字面量创建数组，可以在创建时就指定数组中的元素
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[1，2，3];</span><br></pre></td></tr></table></figure>
    使用构造函数创建数组时，也可以同时添加元素，将需要添加的元素作为构造函数的参数传递
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;new Array(10,20);</span><br></pre></td></tr></table></figure>
    - 创建一个长度为10的数组
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;new Array(10);</span><br></pre></td></tr></table></figure>
    - 数组中的元素可以是任意的数据类型，包括对象，数组也可以放数组
* 数组的常用方法
    - push()
        - 该方法可以在数组的末尾添加一个或多个元素，并返回数组的新长度
    - pop()
        - 该方法可以删除数组中的最后一个元素，并将被删除的元素作为返回值返回
    - unshift()
        - 向数组开头添加一个或多个元素，并返回数组的新长度
        - 向前边加入新的元素后，其他的元素索引会依次调整
    - shift()
        - 该方法可以删除数组中的第一个元素，并将被删除的元素作为返回值返回
    - forEach() 
        - 用来遍历数组，该方法需要一个函数作为参数
        - 像这种函数由我们创建但不由我们调用的称之为回调函数
        - 数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来
            我们可以定义形参来读取这些内容
        - 浏览器会在回调函数中传递三个参数
            第一个参数，就是当前正在遍历的元素
            第二个参数，就是当前正在遍历的元素的索引
            第三个参数，就是正在遍历的数组
        - 该方法只支持IE8以上的浏览器
    - splice()
        - 可以用于删除数组中的指定元素
        - 使用splice()会影响到原数组，会将指定元素从原数组中删除
            并将删除的元素作为返回值返回
        - 参数：
            第一个参数，表示开始位置的索引            
            第二个参数，表示删除的数量            
            第三个及以后的参数，表示传递一些新的元素，这些元素会自动插入到开始位置的索引前
    - slice()
        - 可以用来从数组提取指定元素并将其封装到一个新的数组中作为返回值返回
        - 该方法不会影响到原数组
        - 参数：
            第一个参数，表示开始位置的索引，包括开始索引       
            第二个参数，表示结束位置的索引，不包括结束索引
                第二个参数可以省略不写，此时会截取从开始索引往后的所有元素
            - 索引可以传递一个负值，如果传递一个负值则从后往前计算
                -1 倒数第一个
                -2 倒数第二个....
    - concat() 
        - 该方法可以连接两个或多个数组，并将新的数组返回，该方法不会对原数组产生影响，
            参数也可以填写新的元素
    - join() 
        - 该方法可以将数组转换为一个字符串
        - 该方法不会对原数组产生影响，而是将转换后的字符串作为返回值返回
        - 在该方法中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符
            如果不指定连接符则默认使用,作为连接符
    - reverse()
        - 该方法可以将原数组中的元素颠倒位置，会直接影响原数组
    - sort() 
        - 可以对原数组中的元素进排列
        - 会影响到原数组，默认会按照Unicode编码进行排序
        - 即使对于纯数字的数组，使用该方法排序时也会按照Unicode编码进行排序
            所以对数字进行排序时可能会得到错误的结果
        - 我们可以自己来指定排序的规则，在该方法中添加一个回调函数来指定排序规则
            该回调函数需要定义两个形参，浏览器会分别使用数组中的元素作为实参去调用回调函数
                使用哪个元素调用不确定，但第一个实参在数组中的位置一定在第二个实参之前
        - 浏览器会根据回调函数的返回值来决定元素的顺序
            - 如果返回一个大于0的数则元素会交换位置
            - 如果返回一个小于0的数则元素不会交换位置
            - 如果返回0则元素也不会交换位置
        - 因此若想要升序排列的话，则返回a-b
            若想要降序排列则返回b-a
    - call()和apply()
        - 这两个方法都是函数对象的方法，需要通过函数对象来调用
        - 当对函数调用call()和apply()都会调用函数执行
        - 在调用call()和apply()可以将一个对象指定为第一个参数
            此时这个对象将成为函数执行是时的this
        - call()方法可以将函数对象的实参在指定为第一个参数的对象之后依次传递
        - apply()方法需要将实参封装到一个数组中统一传递
* 在调用函数时，浏览器每次都会传递两个隐含的参数：
    - 函数的上下文对象this
    - 封装实参的对象arguments
        - arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度
        - 在调用函数时，我们所传递的实参都会在arguments中保存
        - arguments.length可以用来获取实参的长度
        - 即使我们不定义形参，也可以通过arguments来使用实参，只不过比较麻烦
            arguments[0] 表示第一个实参
            arguments[1] 表示第二个实参
        - 它里边有一个属性叫做callee
            这个属性对应一个函数对象就是当前正在指向的函数的对象</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/20/Html/Html06/">Html06</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-20
        
    </p>

    

    <!-- Content -->
    <p>表格</p>
<pre><code>* 通过table标签来创建一个表格
    - 在table中使用tr表示表格中的一行，有几个tr就有几行
    - 在tr中使用td表示一个单元格，有几个td就有几个单元格
* 可以将一个表格分成三个部分
    - 头部 thead
        - th 表示头部的单元格
    - 主体 tbody
        - 如果表格中没有使用tbody而是直接使用tr，那么浏览器会自动创建一个tbody
            并将tr全都放到tbody中，因此tr并不是table的子元素
    - 底部 tfoot
* 属性：
    - rowspan 纵向的合并单元格
    - colspan 横向的合并单元格
    - border-spacing 单元格边框之间的距离
    - border-collapse 设置单元格边框的合并
* 默认情况下元素在td中是垂直居中的，可以通过vertical-align来设置
    因此可以将一个元素设置为单元格的形式，这样就可以通过vertical-align来设置元素中的内容</code></pre>
<p>表单</p>
<pre><code>* 通过form标签来创建一个表单
    数据要提交到服务器中，必须要为元素指定一个name属性
* 单选按钮
    - 必须要为其指定一个value属性，value属性最终会作为用户填写的值返回服务器
    - checked 可以将一个选项设置为默认选中
* 属性：
    - autocomplete 设置是否自动补全（显示出曾经填写过的数据）
        - on 默认值，开启自动补全
        - off 关闭自动补全
    - readonly 将表单选项设置为只读，数据会提交
    - disabled，将选项设置为禁用，数据不会提交
    - autofocus 设置某个表单选项自动获取焦点（即一进入光标就锁定到该选项）</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/20/Css/Css14/">Css14</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-20
        
    </p>

    

    <!-- Content -->
    <p>过渡</p>
<pre><code>* 过渡（transition）
    - 通过过渡可以指定一个属性发生变化时的切换方式
    - 通过过渡可以创建一些非常好的效果，提高用户的体验
* 属性：
    - transition-property：指定要执行过渡的属性，多个属性之间使用 ，隔开
                            如果所有属性都需要过渡，则使用all关键字，大部分属性都支持过渡效果
                                过渡时必须是从一个有效数值向另一个有效数值进行过渡（如auto就不行）
    - transition-duration：指定过渡效果的持续时间
    - transition-timing-function：过渡的时序函数，指定过渡的执行方式
        可选值：
            - ease 默认值，先加速，后减速
            - linear 匀速运动
            - ease-in 加速运动
            - ease-out 减速运动
            - ease-in-out 先加速后减速
            - cubic-bezier()（贝塞尔函数）自定义指定时序函数（可用网站查询：https://cubic-bezier.com）
            - step() 分布执行过渡效果
                - 第一个值是分的步数
                - 第二个值（可省略，省略则使用默认值）：
                    - end 默认值，在时间结束时执行过渡
                    - start 在时间开始时执行过渡
    - transition-delay：过渡效果的延迟，等待一段时间后再执行
    - transition：可以同时设置和过渡相关的所有属性，只有一个要求，如果要写延迟，
                    则持续时间必须在延迟时间之前</code></pre>
<p>动画</p>
<pre><code>* 动画（animation）
    - 动画和过渡相似，都是可以实现一些动态的效果，不同的是过渡需要在某个属性发生变化时才会触发
        动画可以自动触发动态效果
    - 设置动态效果，必须先要设置一个关键帧，关键帧设置了动画执行的每一个步骤
* 属性：
    - animation-name：对当前元素生效的关键帧的名字
    - animation-duration：动画的执行时间
    - animation-delay：动画的延迟时间
    - animation-timing-function：动画的时序函数，指定动画的执行方式，规则和可选值与过渡一样
    - animation-iteration-count：动画执行的次数
        可选值：
            - 次数
            - infinite 无限执行
    - animation-direction：指定动画运行的方向
        可选值：
            - normal 默认值 从 from 到 to 运行，每次都是这样
            - reverse 默认值 从 to 到 from 运行，每次都是这样
            - alternate 默认值 从 from 到 to 运行，重复执行动画时反向执行
            - alternate-reverse 默认值 从 to 到 from 运行，重复执行动画时反向执行
    - animation-play-state：设置动画的执行状态
        可选值：
            - running 默认值，动画执行
            - paused 动画暂停
    - animation-fill-mode：设置动画的填充模式
        可选值：
            - none 默认值，动画执行完毕元素回到原来位置
            - forwards 动画执行完毕会停止在动画结束的位置
            - backwards 动画延时等待时，元素就会处于开始位置
            - both 结合了forwards和backwards</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/20/Css/Css13/">Css13</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-20
        
    </p>

    

    <!-- Content -->
    <p>背景background</p>
<pre><code>* background-color 设置背景颜色
* background-image 设置背景图片
    - 可以同时设置背景图片和颜色，这样背景颜色将会成为图片的背景色
    - 如果背景图片小于元素，则背景图片会自动重复将元素铺满
    - 如果背景图片大于元素，则背景图片的溢出部分将不会显示
    - 如果背景图片和元素一样大，则背景图片正常显示
* background-repeat 设置背景的重复方式
    可选值：
        - repeat 默认值，背景会沿着X和Y轴双方向重复
        - repeat-x 沿着X轴方向重复
        - repeat-y 沿着Y轴方向重复
        - no-repeat 背景图片不重复
* background-position 设置背景图片的位置
    设置方式：
        - 通过top left right bottom center来设置背景图片的位置
            使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center
        - 通过偏移量来设置背景图片的位置，第一个值是水平方向偏移量，第二个值是垂直方向偏移量
* background-size 设置背景图片的大小
    - 第一个值表示宽度，第二个值表示高度
    - 如果只写一个值，则第二个值默认是auto
    - cover 图片比例不变，将元素铺满
    - contain 图片比例不变，将图片在元素中完整显示
* background-origin 设置背景图片偏移量计算的原点
    - padding-box 默认值，背景图片的偏移量（background-position）从内边距开始计算
    - content-box 默认值，背景图片的偏移量（background-position）从内容区开始计算
    - border-box 默认值，背景图片的偏移量（background-position）从边框开始计算
* background-clip 设置背景图片的范围
    - padding-box 默认值，背景图片出现在内边距以内
    - content-box 默认值，背景图片出现在内容区以内
    - border-box 默认值，背景图片出现在边框以内
* background-attachment 设置背景图片是否跟随元素移动
    - scroll 默认值，背景图片会跟随元素移动
    - fixed 背景会固定在页面中，不会跟随元素移动
* background 背景相关的简写属性，所有与背景相关的样式都可以通过该属性来设置
    注意：background-size必须写在background-position的后边，并且使用/隔开
        background-clip必须写在background-origin的后边（最好不使用简写，可读性差）</code></pre>
<p>雪碧图</p>
<pre><code>* 图片属于网页中的外部资源，外部资源都需要浏览器单独发送请求加载
    浏览器加载外部资源都是按需加载的，用则加载，不用则不加载
     因此当我们给一个元素设置在不同情况下的不同背景图片时，使用多个图片切换会出现闪烁问题
* 解决图片闪烁的问题：可以将多个小图片统一保存到一个大图片中，
    然后通过调整background-position来显示想要的图片，这样图片会同时加载到网页中，
        就可以有效地避免出现闪烁的问题，这个技术在网页中应用广泛，称为CSS-Sprite，也就是雪碧图
* 雪碧图的使用：
    - 首先确定要使用的图标
    - 测量图标大小
    - 根据测量结果创建一个元素
    - 将雪碧图设置为元素的背景图片
    - 设置偏移量来显示想要的图片
* 雪碧图的特点：一次性将多个图片加载进网页，降低请求次数，加快访问速度，提高用户体验</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/15/JavaScript/JavaScript05/">JavaScript05</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-15
        
    </p>

    

    <!-- Content -->
    <p>JavaScript构造函数</p>
<pre><code>* 构造函数就是一个普通的函数，创建方式和普通函数没什么区别，不同的是构造函数习惯首字母大写
    还有就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用
* 构造函数的执行流程：
    1.创建一个新的对象
    2.将新的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
    3.逐行执行函数中的代码
    4.将新建的对象作为返回值返回
* 使用通过一个构造函数创建的对象称为一类对象，也将一个构造函数称为一个类
    通过一个构造函数创建的对象则称为是该类的实例
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,gender)</span><br><span class="line">&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">    this.age&#x3D;age;</span><br><span class="line">    this.gender&#x3D;gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 使用instanceof可以检查一个对象是否是一个类的实例
    如果是则返回true，否则返回false
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(per instanceof Person);</span><br></pre></td></tr></table></figure>
* 若在构造函数中将一个属性值设置为一个函数方法，则构造函数每执行一次就会创建一个新的方法
    这就会导致空间浪费，我们可以用以下两个方法解决
        - 将函数在全局作用域中定义，再将其赋值给构造函数的属性值
            但将函数定义在全局作用域会污染全局作用域的命名空间
                且不太安全
        - 将函数定义在构造函数的原型对象中</code></pre>
<p>原型prototype</p>
<pre><code>* 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
    这个属性对应着一个对象，这个对象就是原型对象，如果以普通函数来调用prototype没有任何作用
            但当函数以构造函数的形式来调用时，它所创建的对象都会有一个隐含的属性指向该构造对象的原型对象
                我们可以通过__proto__（注意前后分别是两个下划线）来访问该对象
* 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象
    我们可以将对象中共有的内容统一设置到原型对象中
* 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用
    如果没有则会去原型对象中寻找，如果找到则直接使用
* 原型对象也是对象，所以它也有原型
    当使用一个对象的属性或方法时会在自身中寻找
          如果没有则会去原型对象中寻找
            如果还是没有则区原型的原型中寻找，直到找到Object对象的原型
                Object对象的原型没有原型，若Object中还是没找到则返回undefined</code></pre>
<p>toString()方法</p>
<pre><code>* 当我们直接在页面中打印一个对象时，实际上输出的是对象的toString()方法的返回值
    我们可以通过为对象添加一个toString()方法来改变输出的值</code></pre>
<p>垃圾回收（GC）</p>
<pre><code>* 程序运行过程中会产生垃圾，当一个对象没有任何的变量或属性对它进行引用时，此对象就是一个垃圾
    在JS中拥有自动的垃圾回收机制，会自动地将这些垃圾对象从内存中销毁
        我们只需要将不再使用的垃圾对象设置为null即可</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/12/Css/Css12/">Css12</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-12
        
    </p>

    

    <!-- Content -->
    <p>字体</p>
<pre><code>* font可以设置字体相关的所有属性
    - 语法：
            font：字重 字体风格 字体大小/行高 字体族
            行高可以省略不写，将使用默认值
* font-family字体族（字体的格式）
    - 可选值：
        - serif 衬线字体
        - sans-serif 非衬线字体
        - monospace 等宽字体
    - font-family可以同时指定多个字体，多个字体之间用 ， 隔开
        字体生效时优先使用第一个，第一个无法使用再使用第二个，以此类推
* font-weight 字重 字体的加粗
    可选值：
        - normal 默认值，不加粗
        - bold 加粗
            100-900 九个级别（没什么用，主要取决于电脑是否有这么多个种类的字体）
* font-style 字体风格
    可选值：
        - normal 默认值，正常的
        - italic 斜体
* 图标字体（iconfont）
    - 在网页中经常需要使用一些图标，可以通过图片引入图标
        但图片本身大小比较大，并且非常的不灵活
    - 所以在使用图标时，我们还可以将图标直接设置为字体
        然后通过font-face的形式来对字体进行引入
    - 使用图标字体的方式
        - 直接通过类名来使用图标字体
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class&#x3D;&quot;fas fa-bell&quot;;</span><br><span class="line">class&#x3D;&quot;fab fa-accessible-icon&quot;</span><br></pre></td></tr></table></figure>
    - 通过伪元素来设置图标字体
        - 找到要设置图标的元素通过before或after选中
        - 在content中设置字体的编码
        - 设置字体的样式
    - 通过实体来使用图标字体
        - &amp;#x图标的编码</code></pre>
<p>行高</p>
<pre><code>* 行高（line height）
    - 行高指的是文字占有的实际高度
    - 可以通过line-height来设置行高
        行高可以指定一个大小（px em）
            也可以直接为行高设置一个整数
                若是一个整数的话，行高将会是字体的指定的倍数
    - 行高还可以用来设置文字的行间距
        行间距=行高-字体大小
* 字体框
    - 字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度
* 行高会在字体框的上下平均分配
* 可以将行高设置为和高度一样的值，使单行文字在一个元素中垂直居中</code></pre>
<p>文本修饰</p>
<pre><code>* vertical-align 设置元素垂直对齐的方式
    可选值：
        - baseline 默认值，基线对齐
        - top 顶部对齐
        - bottom 底部对齐
        - middle 居中对齐
* text-decoration 设置文本修饰
    可选值：
        - none 什么都没有
        - underline 下划线
        - line-through 删除线
        - overline 上划线
* white-space 设置网页如何处理空白
    可选值：
        - normal 正常
        - nowrap 不换行
        - pre 保留空白</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/12/JavaScript/JavaScript04/">JavaScript04</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-12
        
    </p>

    

    <!-- Content -->
    <p>JavaScript函数（Function）</p>
<pre><code>* 立即执行函数（自调用函数）
    - 函数定义完立即被调用，这种函数叫做立即执行函数
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
* 函数也可以成为对象的属性
    - 如果一个函数作为一个对象的属性保存
        那么称这个函数是这个对象的方法
            调用这个函数就说调用对象的方法（method）
    - 调用函数和调用对象的方法本质上没有区别
* 枚举对象中的属性
    - 使用for...in语句
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var n in obj)&#123;</span><br><span class="line">    consloe.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - for...in语句，对象中有几个属性，循环体就会执行几次
        每次执行时会将对象中的一个属性的名字赋值给变量n</code></pre>
<p>声明提前</p>
<pre><code>* 变量的声明提前
    - 使用var关键字声明的变量会在所有的代码执行之前被声明（但不会被赋值）
    - 不使用var关键字声明变量则不会提前
* 函数的声明提前
    - 使用函数声明形式创建的函数会在所有的代码执行之前被创建
        所以可以在函数声明之前来调用函数
    - 使用函数表达式创建的函数不会被声明提前，所以不能在声明之前调用</code></pre>
<p>作用域</p>
<pre><code>* 作用域指一个变量作用的范围，在JS中一共有两种作用域：
    - 全局作用域
        - 直接编写在script标签中的JS代码都是全局作用域
        - 全局作用域在页面打开时创建，在页面关闭时销毁
        - 在全局作用域中有一个全局对象window
            它代表的是一个浏览器的窗口，有浏览器创建，我们可以直接使用
        - 在全局作用域中：
            - 创建的变量都会作为window对象的属性保存
            - 创建的函数都会作为window对象的方法保存
        - 全局作用域中的都是全局变量
            在页面的任意的部分都可以访问的到
    - 函数作用域
        - 调用函数时创建函数作用域，函数执行完毕时摧毁
        - 每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的
        - 在函数作用域中可以访问到全局作用域的变量
            反之却不行
        - 当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用
            如果没有则向上一级作用域中寻找，直到找到全局作用域
                如果全局作用域中依然没有找到则会报错ReferenceError
        - 在函数中要访问全局变量可以使用window对象</code></pre>
<p>this参数</p>
<pre><code>* 解析器在调用函数时每次都会向函数内部传递一个隐含的this参数
    - this参数指向的值一个对象，这个对象称之为函数执行的上下文对象
    - 根据函数的调用方式的不同，this会指向不同的对象
        - 以函数的形式调用时，this永远都是window
        - 以方法的形式调用时，this就是调用方法的那个对象
        - 以构造函数的方式调用时，this就是新创建的那个对象
        - 使用call()和apply()调用时，this就是指定的那个对象</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>




<div id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    主题 <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/main.js"></script>


</body>

</html>
