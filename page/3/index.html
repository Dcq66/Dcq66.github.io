<html>

<head>
    <meta charset="utf-8">
    
    <title>小戴的学习日记</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/tagplugins.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="小戴的学习日记" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Dcq66.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">小戴的学习日记</h1>
    <p class="lead blog-description">Dcq66.github.io</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/20/Css/Css13/">Css13</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-20
        
    </p>

    

    <!-- Content -->
    <p>背景background</p>
<pre><code>* background-color 设置背景颜色
* background-image 设置背景图片
    - 可以同时设置背景图片和颜色，这样背景颜色将会成为图片的背景色
    - 如果背景图片小于元素，则背景图片会自动重复将元素铺满
    - 如果背景图片大于元素，则背景图片的溢出部分将不会显示
    - 如果背景图片和元素一样大，则背景图片正常显示
* background-repeat 设置背景的重复方式
    可选值：
        - repeat 默认值，背景会沿着X和Y轴双方向重复
        - repeat-x 沿着X轴方向重复
        - repeat-y 沿着Y轴方向重复
        - no-repeat 背景图片不重复
* background-position 设置背景图片的位置
    设置方式：
        - 通过top left right bottom center来设置背景图片的位置
            使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center
        - 通过偏移量来设置背景图片的位置，第一个值是水平方向偏移量，第二个值是垂直方向偏移量
* background-size 设置背景图片的大小
    - 第一个值表示宽度，第二个值表示高度
    - 如果只写一个值，则第二个值默认是auto
    - cover 图片比例不变，将元素铺满
    - contain 图片比例不变，将图片在元素中完整显示
* background-origin 设置背景图片偏移量计算的原点
    - padding-box 默认值，背景图片的偏移量（background-position）从内边距开始计算
    - content-box 默认值，背景图片的偏移量（background-position）从内容区开始计算
    - border-box 默认值，背景图片的偏移量（background-position）从边框开始计算
* background-clip 设置背景图片的范围
    - padding-box 默认值，背景图片出现在内边距以内
    - content-box 默认值，背景图片出现在内容区以内
    - border-box 默认值，背景图片出现在边框以内
* background-attachment 设置背景图片是否跟随元素移动
    - scroll 默认值，背景图片会跟随元素移动
    - fixed 背景会固定在页面中，不会跟随元素移动
* background 背景相关的简写属性，所有与背景相关的样式都可以通过该属性来设置
    注意：background-size必须写在background-position的后边，并且使用/隔开
        background-clip必须写在background-origin的后边（最好不使用简写，可读性差）</code></pre>
<p>雪碧图</p>
<pre><code>* 图片属于网页中的外部资源，外部资源都需要浏览器单独发送请求加载
    浏览器加载外部资源都是按需加载的，用则加载，不用则不加载
     因此当我们给一个元素设置在不同情况下的不同背景图片时，使用多个图片切换会出现闪烁问题
* 解决图片闪烁的问题：可以将多个小图片统一保存到一个大图片中，
    然后通过调整background-position来显示想要的图片，这样图片会同时加载到网页中，
        就可以有效地避免出现闪烁的问题，这个技术在网页中应用广泛，称为CSS-Sprite，也就是雪碧图
* 雪碧图的使用：
    - 首先确定要使用的图标
    - 测量图标大小
    - 根据测量结果创建一个元素
    - 将雪碧图设置为元素的背景图片
    - 设置偏移量来显示想要的图片
* 雪碧图的特点：一次性将多个图片加载进网页，降低请求次数，加快访问速度，提高用户体验</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/15/JavaScript/JavaScript05/">JavaScript05</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-15
        
    </p>

    

    <!-- Content -->
    <p>JavaScript构造函数</p>
<pre><code>* 构造函数就是一个普通的函数，创建方式和普通函数没什么区别，不同的是构造函数习惯首字母大写
    还有就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用
* 构造函数的执行流程：
    1.创建一个新的对象
    2.将新的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
    3.逐行执行函数中的代码
    4.将新建的对象作为返回值返回
* 使用通过一个构造函数创建的对象称为一类对象，也将一个构造函数称为一个类
    通过一个构造函数创建的对象则称为是该类的实例
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,gender)</span><br><span class="line">&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">    this.age&#x3D;age;</span><br><span class="line">    this.gender&#x3D;gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 使用instanceof可以检查一个对象是否是一个类的实例
    如果是则返回true，否则返回false
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(per instanceof Person);</span><br></pre></td></tr></table></figure>
* 若在构造函数中将一个属性值设置为一个函数方法，则构造函数每执行一次就会创建一个新的方法
    这就会导致空间浪费，我们可以用以下两个方法解决
        - 将函数在全局作用域中定义，再将其赋值给构造函数的属性值
            但将函数定义在全局作用域会污染全局作用域的命名空间
                且不太安全
        - 将函数定义在构造函数的原型对象中</code></pre>
<p>原型prototype</p>
<pre><code>* 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
    这个属性对应着一个对象，这个对象就是原型对象，如果以普通函数来调用prototype没有任何作用
            但当函数以构造函数的形式来调用时，它所创建的对象都会有一个隐含的属性指向该构造对象的原型对象
                我们可以通过__proto__（注意前后分别是两个下划线）来访问该对象
* 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象
    我们可以将对象中共有的内容统一设置到原型对象中
* 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用
    如果没有则会去原型对象中寻找，如果找到则直接使用
* 原型对象也是对象，所以它也有原型
    当使用一个对象的属性或方法时会在自身中寻找
          如果没有则会去原型对象中寻找
            如果还是没有则区原型的原型中寻找，直到找到Object对象的原型
                Object对象的原型没有原型，若Object中还是没找到则返回undefined</code></pre>
<p>toString()方法</p>
<pre><code>* 当我们直接在页面中打印一个对象时，实际上输出的是对象的toString()方法的返回值
    我们可以通过为对象添加一个toString()方法来改变输出的值</code></pre>
<p>垃圾回收（GC）</p>
<pre><code>* 程序运行过程中会产生垃圾，当一个对象没有任何的变量或属性对它进行引用时，此对象就是一个垃圾
    在JS中拥有自动的垃圾回收机制，会自动地将这些垃圾对象从内存中销毁
        我们只需要将不再使用的垃圾对象设置为null即可</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/12/Css/Css12/">Css12</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-12
        
    </p>

    

    <!-- Content -->
    <p>字体</p>
<pre><code>* font可以设置字体相关的所有属性
    - 语法：
            font：字重 字体风格 字体大小/行高 字体族
            行高可以省略不写，将使用默认值
* font-family字体族（字体的格式）
    - 可选值：
        - serif 衬线字体
        - sans-serif 非衬线字体
        - monospace 等宽字体
    - font-family可以同时指定多个字体，多个字体之间用 ， 隔开
        字体生效时优先使用第一个，第一个无法使用再使用第二个，以此类推
* font-weight 字重 字体的加粗
    可选值：
        - normal 默认值，不加粗
        - bold 加粗
            100-900 九个级别（没什么用，主要取决于电脑是否有这么多个种类的字体）
* font-style 字体风格
    可选值：
        - normal 默认值，正常的
        - italic 斜体
* 图标字体（iconfont）
    - 在网页中经常需要使用一些图标，可以通过图片引入图标
        但图片本身大小比较大，并且非常的不灵活
    - 所以在使用图标时，我们还可以将图标直接设置为字体
        然后通过font-face的形式来对字体进行引入
    - 使用图标字体的方式
        - 直接通过类名来使用图标字体
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class&#x3D;&quot;fas fa-bell&quot;;</span><br><span class="line">class&#x3D;&quot;fab fa-accessible-icon&quot;</span><br></pre></td></tr></table></figure>
    - 通过伪元素来设置图标字体
        - 找到要设置图标的元素通过before或after选中
        - 在content中设置字体的编码
        - 设置字体的样式
    - 通过实体来使用图标字体
        - &amp;#x图标的编码</code></pre>
<p>行高</p>
<pre><code>* 行高（line height）
    - 行高指的是文字占有的实际高度
    - 可以通过line-height来设置行高
        行高可以指定一个大小（px em）
            也可以直接为行高设置一个整数
                若是一个整数的话，行高将会是字体的指定的倍数
    - 行高还可以用来设置文字的行间距
        行间距=行高-字体大小
* 字体框
    - 字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度
* 行高会在字体框的上下平均分配
* 可以将行高设置为和高度一样的值，使单行文字在一个元素中垂直居中</code></pre>
<p>文本修饰</p>
<pre><code>* vertical-align 设置元素垂直对齐的方式
    可选值：
        - baseline 默认值，基线对齐
        - top 顶部对齐
        - bottom 底部对齐
        - middle 居中对齐
* text-decoration 设置文本修饰
    可选值：
        - none 什么都没有
        - underline 下划线
        - line-through 删除线
        - overline 上划线
* white-space 设置网页如何处理空白
    可选值：
        - normal 正常
        - nowrap 不换行
        - pre 保留空白</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/12/JavaScript/JavaScript04/">JavaScript04</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-12
        
    </p>

    

    <!-- Content -->
    <p>JavaScript函数（Function）</p>
<pre><code>* 立即执行函数（自调用函数）
    - 函数定义完立即被调用，这种函数叫做立即执行函数
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
* 函数也可以成为对象的属性
    - 如果一个函数作为一个对象的属性保存
        那么称这个函数是这个对象的方法
            调用这个函数就说调用对象的方法（method）
    - 调用函数和调用对象的方法本质上没有区别
* 枚举对象中的属性
    - 使用for...in语句
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var n in obj)&#123;</span><br><span class="line">    consloe.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - for...in语句，对象中有几个属性，循环体就会执行几次
        每次执行时会将对象中的一个属性的名字赋值给变量n</code></pre>
<p>声明提前</p>
<pre><code>* 变量的声明提前
    - 使用var关键字声明的变量会在所有的代码执行之前被声明（但不会被赋值）
    - 不使用var关键字声明变量则不会提前
* 函数的声明提前
    - 使用函数声明形式创建的函数会在所有的代码执行之前被创建
        所以可以在函数声明之前来调用函数
    - 使用函数表达式创建的函数不会被声明提前，所以不能在声明之前调用</code></pre>
<p>作用域</p>
<pre><code>* 作用域指一个变量作用的范围，在JS中一共有两种作用域：
    - 全局作用域
        - 直接编写在script标签中的JS代码都是全局作用域
        - 全局作用域在页面打开时创建，在页面关闭时销毁
        - 在全局作用域中有一个全局对象window
            它代表的是一个浏览器的窗口，有浏览器创建，我们可以直接使用
        - 在全局作用域中：
            - 创建的变量都会作为window对象的属性保存
            - 创建的函数都会作为window对象的方法保存
        - 全局作用域中的都是全局变量
            在页面的任意的部分都可以访问的到
    - 函数作用域
        - 调用函数时创建函数作用域，函数执行完毕时摧毁
        - 每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的
        - 在函数作用域中可以访问到全局作用域的变量
            反之却不行
        - 当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用
            如果没有则向上一级作用域中寻找，直到找到全局作用域
                如果全局作用域中依然没有找到则会报错ReferenceError
        - 在函数中要访问全局变量可以使用window对象</code></pre>
<p>this参数</p>
<pre><code>* 解析器在调用函数时每次都会向函数内部传递一个隐含的this参数
    - this参数指向的值一个对象，这个对象称之为函数执行的上下文对象
    - 根据函数的调用方式的不同，this会指向不同的对象
        - 以函数的形式调用时，this永远都是window
        - 以方法的形式调用时，this就是调用方法的那个对象
        - 以构造函数的方式调用时，this就是新创建的那个对象
        - 使用call()和apply()调用时，this就是指定的那个对象</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/11/JavaScript/JavaScript03/">JavaScript03</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-11
        
    </p>

    

    <!-- Content -->
    <p>JavaScript对象(Object)</p>
<pre><code>* 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性
* 对象的分类：
    - 内建对象：
        - 由ES标准中定义的对象，在任何的ES的实现中都可以使用
        - 比如：Math String Number Boolean
    - 宿主对象：
        - 由JS的运行环境提供的对象，目前来讲主要是指由浏览器提供的对象
        - 比如：BOM DOM
    - 自定义对象：
        - 由开发人员自己创建的对象
* 使用对象字面量创建对象
    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="number">1</span>,</span><br><span class="line">    age:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 属性值
    - JS对象的属性值可以是任意的数据类型
        甚至也可以是一个对象
* in 运算符
    - 通过该运算符可以检查一个对象中是否含有指定的属性
        有则返回true，反之返回false
    - 语法：
        &quot;属性名&quot; in 对象  例子如
        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> obj);</span><br></pre></td></tr></table></figure>
* 如果要使用特殊的属性名，不能采用.的方式来操作
        需要使用另一种方式
    - 语法：对象[&quot;属性名&quot;]=属性值
        读取时也要采取这种方式
    - 使用[]这种形式去操作属性，更加的灵活
        在[]中可以去直接传递一个变量，这样变量值是多少就会读取那个属性
* 堆内存和栈内存
    - JS中的变量都是保存到栈内存中的
        基本数据类型的值直接在栈内存中存储
            值与值之间是相互独立的，修改一个变量不会影响到另一个变量
    - 对象是保存到堆内存的，每创建一个新的对象就会在对内存中开辟出一个新的空间
        而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用
            当一个变量修改属性时，另一个也会受到影响
    - 当比较两个基本数据类型的值时，就是比较值
        而比较两个引用数据类型时，它比较的是对象的内存地址
            如果两个对象是一模一样的，但是地址不同，它也会返回false</code></pre>
<p>JavaScript函数（Function）</p>
<pre><code>* 函数Function
    - 函数也是一个对象
    - 函数可以封装一些功能（代码），在需要时可以执行这些功能（代码）
    - 使用typeof检查一个函数对象时，返回function
* 创建函数的方式
    - 使用构造函数来创建一个函数对象（实际开发中很少用）
    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun=<span class="keyword">new</span> <span class="built_in">Function</span>();</span><br></pre></td></tr></table></figure>
    - 使用函数声明来创建一个函数，可在括号中加入形参
    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - 使用函数表达式来创建一个函数
    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun=<span class="keyword">new</span> <span class="function"><span class="title">Function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 可以使用return来设置函数的返回值
    - 语法：return 值
        return后的值将会作为函数的执行结果返回
            可以定义一个变量来接收
    - 函数中启用return后的语句都不会继续执行
    - 如果return语句后不跟任何值就相当于返回一个undefined
        如果函数中不写return，则也会返回undefined
* 形参和实参
    - 可以在函数的()中来指定一个或多个形参（形式参数）
        多个形参之间使用 ，隔开，声明形参就相当于在函数内部声明了对应的变量但不赋值
    - 在调用函数时，可以在()中指定实参（实际参数可以是任意的数据类型）
        实参会赋值给函数中对应的形参
    - 调用函数时解析器不会检查实参的类型
        所以要注意是否会接收到非法的参数，如果有可能则需要对参数进行类型的检查
    - 调用函数时解析器也不会检查实参的数量
        多余实参不会被赋值
            如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/05/Css/Css11/">Css11</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-05
        
    </p>

    

    <!-- Content -->
    <p>CSS中的定位</p>
<pre><code>* 定位（position）
    - 定位是一种更加高级的布局手段
    - 通过定位可以将元素摆放到页面的任意位置
    - 使用position属性来设置定位
        可选值：
            - static 默认值，元素是静止的，没有开启定位
            - relative 开启元素的相对定位
            - absolute1 开启元素的绝对定位
            - fixed 开启元素的固定定位
            - sticky 开启元素的粘滞定位</code></pre>
<p>相对定位</p>
<pre><code>* 当元素的position属性设置为relative时则开启了元素的相对定位
* 相对定位的特点：
    - 不设置偏移量元素不会发生任何的变化
    - 相对定位是参照元素在文档流种的位置进行定位
    - 相对定位会提高元素的层级
    - 相对定位不会使元素脱离文档流
    - 相对定位不会改变元素的性质，块元素还是块元素，行内元素还是行内元素
* 偏移量（offset）
    - 当元素开启定位以后，可以通过偏移量来设置元素的位置
        - top
            - 定位元素和定位位置上边的距离
        - bottom
            - 定位元素和定位位置下边的距离
            -定位元素垂直方向的位置由top和bottom两个属性来控制
                通常情况下我们只会使用其中之一
        - left
            - 定位元素和定位位置左边的距离
        - right
            - 定位元素和定位位置右边的距离
            定位元素水平方向的位置由left和right两个属性来控制
                通常情况下我们只会使用其中之一</code></pre>
<p>绝对定位</p>
<pre><code>* 当元素的position属性设置为absolute时，则开启了元素的绝对定位
* 绝对定位的特点：
    - 不设置偏移量元素不会发生任何的变化
    - 元素会从文档流中脱离
    - 会改变元素的性质，块的宽高被内容撑开
    - 会提高元素的层级
    - 绝对定位元素是相对于其包含块进行定位的
        - 包含块（containing block）
            - 正常情况下，包含块就是离当前元素最近的祖先块元素
            - 绝对定位的包含块则是离当前元素最近的开启了定位的祖先元素
                如果所有的祖先元素都没有开启定位则根元素（html 初始包含块）就是它的包含块
* 当我们开启了绝对定位后，水平布局等式就需要添加left和right两个值
    此时规则和之前一样，只是多了两个值
        - 当发生过度约束：
            - 如果九个值中没有auto则自动调整right以使等是满足
            - 如果有auto则自动调整auto的值以使等是满足
        - 可设置auto的值有margin、width、left、right
        - 因为left和right的值默认是auto，所以如果不指定这两个值
            则等式不满足时会自动调整这两个值
* 开启绝对定位时，垂直方向的布局也必须满足等式
    top+margin-top/bottom+padding-top/bottom+border-top/bottom+bottom
* 因此当开启绝对定位时，我们可以利用水平和垂直的布局等式令元素水平垂直居中</code></pre>
<p>固定定位</p>
<pre><code>* 当元素的position属性设置为fixed时，则开启了元素的固定定位
* 固定定位也是一种绝对定位，绝大部分特点与其一致
    唯一不同的是固定定位永远参照于浏览器的可视窗口进行定位
    不会随着网页的滚动条滚动</code></pre>
<p>粘滞定位</p>
<pre><code>* 当元素的position属性设置为sticky时，则开启了元素的粘滞定位
* 粘滞定位于相对定位特点基本一致
    不同的是站指定位可以在元素到达某个位置时将其固定</code></pre>
<p>层级</p>
<pre><code>* 开启定位后的元素，可以通过z-index属性来设置元素的层级
    - z-index的值越大元素的层级越大
        元素的层级越大越优先显示
    - 如果元素的层级一样则优先显示靠下的元素
    - 祖先元素的层级再高也不会盖住后代元素</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/05/JavaScript/JavaScript02/">JavaScript02</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-05
        
    </p>

    

    <!-- Content -->
    <p>多进制的数字</p>
<pre><code>* 在JS中表达不同进制的数字需要用不同的表达方式
    - 如表达16进制的数字，则需要以0x开头
    - 如表达8进制的数字，则需要以0开头
    - 如表达2进制的数字，则需要以0b开头</code></pre>
<p>运算符</p>
<pre><code>* 运算符也叫操作符
    - 通过运算符可以对一个或多个值进行运算并获取运算结果
    - 如：typeof就是运算符，可以来获取一个值的类型
            它会将该值的类型以字符串的形式返回
* 算术运算符
    当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算
        任何值和做运算都得NaN
    +
        + 可以对两个值进行加法运算并将结果返回
        任何值和字符串相加都会做拼串操作，拼接成一个字符串
        我们可以利用这一特性，将一个任意的数据类型转换为String
        只需要为任意的数据类型+一个&quot;&quot;即可将其转换为String
        这是一种隐式的转换，有浏览器自动完成，实际上也是调用String()函数
    - 
        - 可以对两个值进行减法运算并将结果返回
    *  
        * 可以对两个值进行乘法运算并将结果返回
    /
        / 可以对两个值进行除法运算并将结果返回
    %
        % 取模运算（取余数）
    =
        = 将符号右侧的值赋值给符号左侧的变量
    +=
        += a += 5 等价于 a = a + 5
    -=
        -= a -= 5 等价于 a = a - 5
    *=
        *= a *= 5 等价于 a = a * 5
    /=
        /= a /= 5 等价于 a = a / 5
    %=
        %= a %= 5 等价于 a = a % 5
* 任何值做- * /运算时都会自动转换为Number
    我们可以利用这一特点做隐式的类型转换
    可以通过为一个值-0 *1 /1来将其转换为Number
    原理和Number()函数一样
* 一元运算符
    - 正号
        +（正号）不会对数字产生任何影响
    - 负号
        -（负号）可以对数字进行取反
    - 对于非Number类型的值
        它会将其转换为Number，然后再运算
        可以对一个其他的数据类型使用+，来将其转换为number
        它的原理和Number()函数一样
    - 自增++
        - 通过自增可以使变量在自身基础上增加1
        - 对于一个变量自增以后，原变量的值会立刻自增1
        - 自增分成两种：前++（++a）和后++（a++）
            无论是前++还是后++都会使原变量的值自增1
            不同的是前++和后++本身的值
            前++（++a）的值等于新值（自增后的值）
            后++（a++）的值等于原变量的值（自增前的值）
    - 自减--
        - 通过自减可以使变量在自身基础上减1
        - 对于一个变量自减以后，原变量的值会立刻自减1
        - 自减分成两种：前--（--a）和后--（a--）
            无论是前--还是后--都会使原变量的值自减1
            不同的是前--和后--本身的值
            前--（--a）的值等于新值（自减后的值）
            后--（a--）的值等于原变量的值（自减前的值）
* 逻辑运算符
    - ！（非）
        - ！可以用来对一个值进行非运算
        - 所谓非运算就是对一个布尔值进行取反操作
            true变false，false变true
        - 如果对一个非布尔值进行取反，则会将其转换为布尔值然后再取反
            所以可以利用该特点将一个其他数据类型转换为布尔值
    - &amp;&amp;（与）
        - &amp;&amp;可以对符号两侧的值进行与运算并返回结果
        - JS中的“与”属于短路与
            如果第一个值为false，则不会看第二个值
    - ||（或）
        - ||可以对符号两侧的值进行或运算并返回结果
        - JS中的“或”属于短路或
            如果第一个值为true，则不会看第二个值
    - &amp;&amp; || 非布尔值的情况
        - 对于非布尔值进行与或运算时
            会先将其转换为布尔值，然后再运算，并且返回原值
        - 与运算：
            - 如果第一个值为true，则必然返回第二个值
            - 如果第一个值为false，则必然返回第一个值
        - 或运算：
            - 如果第一个值为true，则必然返回第一个值
            - 如果第一个值为false，则必然返回第二个值
* 关系运算符
    - 如果关系成立则返回true，反之则返回false
    &gt; 大于号
    &gt;= 大于等于
    &lt; 小于号
    &lt;= 小于等于
    == 相等
    != 不相等
    === 全等：如果两个值的类型不同，直接返回false
    !== 不全等：如果两个值的类型不同，直接返回true
        - 任何值和NaN做任何比较都是false
        - 比较两个字符串时，比较的是字符串的字符编码（Unicode编码）
            比较字符编码时是一位一位进行比较
            如果两位一样则比较下一位
        - undefined衍生自null
            所以这两个值做相等判断时，会返回true
        - NaN不和任何值相等，包括它本身
* 条件运算符（三目运算符）
    - 语法：
        条件表达式?语句1:语句2;
    - 如果条件的表达式的求值结果是一个非布尔值
        则将其转换为布尔值然后再运算</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/04/JavaScript/JavaScript01/">JavaScript01</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-04
        
    </p>

    

    <!-- Content -->
    <p>语法规范：</p>
<pre><code>* JS中严格区分大小写
* JS中每一条语句以分号结尾
    - 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源
        而且有些时候，浏览器会加错分号，所以在开发中分号必须写
* JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化
* 在JS中可以使用&#123;&#125;来为语句进行分组
    同一个&#123;&#125;中的语句我们称为是一组语句
    它们要么都执行，要么都不执行
        一个&#123;&#125;中的语句我们也称为一个代码块
            在JS中的代码块只具有分组的作用
                代码块的内容在外部都是完全可见的</code></pre>
<p>编写位置</p>
<pre><code>* 编写在标签内
    - 可以将js代码编写到标签的onclick属性中，当我们点击按钮时，js代码才会执行
    - 可以将js代码写在超链接的href属性中，这样当点击超链接时会执行js代码
* 将js代码编写到script标签中
* 引入外部js文件
    - 将js代码编写到外部到外部js文件中，然后通过script标签引入
        写到外部文件中可以在不同的页面中同时引用，
            推荐的使用方法
    - script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略
        如果需要则可以再创建一个新的script标签用于编写内部代码</code></pre>
<p>字面量、变量和标识符</p>
<pre><code>* 字面量：都是一些不可改变的值
    - 如：1 2 3 4 5
    - 字面量都是可以直接使用的，但我们一般都不会直接使用字面量
* 变量：变量的值可以任意改变
    - 变量可以用来保存字面量，更加方便我们使用，所以在开发中都是通过变量去保存一个字面量
        而很少直接使用字面量
    - 在js使用var关键字来声明一个变量
* 标识符
    - 在JS中所有的可以由我们自主命名的都可以称为是标识符
    - 如：变量名、函数名、属性名都属于标识符
    - 命名一个标识符时需要遵循如下的规则：
        - 标识符中可以含有字母、数字、_、$
        - 标识符不能以数字开头
        - 标识符不能是JS中的关键字和保留字
    - JS底层保存标识符时实际上使用的是Unicode编码
        所以理论上讲，所有的utf-8中含有的内容都可以作为标识符</code></pre>
<p>数据类型</p>
<pre><code>* 可以使用一个运算符typeof来检查一个变量的类型
    - 语法：typeof 变量
    - 检查字符串时，会返回string
    - 检查数值时，会返回number

* 数据类型指的就是字面量的类型，在js中一共有六种数据类型：
    - String 字符串
        - 在JS中字符串需要使用引号引起来
        - 使用双引号或单引号都可以，但不能混合使用
        - 引号不能嵌套，双引号不能放双引号，单引号也是
        - 在字符串中我们可以使用\作为转义字符
            - \&quot; 表示 &quot;
            - \&#39; 表示 &#39;
            - \n 表示换行
            - \t 表示制表符（Tab）
            - \\ 表示 \
    - Number 数值
        - 包括整数和浮点数（小数）
        - 可以表达的数字的最大值为Number.MAX_VALUE（1.7976931348623157e+308）
        - 可以表达的大于零的数字的最小值为Number.MIN_VALUE（5e-324）
        - 如果使用Number表示的数字超过了最大值，则会返回一个
            Infinity 表示正无穷
            -Infinity 表示负无穷
            使用typeof检查Infinity也会返回number
        - NaN是一个特殊的数字，表示Not A Number
            使用typeof检查一个NaN也会返回number
        - 在JS中整数的运算基本可以保证精确
            但如果进行浮点运算可能会得到一个不精确的结果
    - Boolean 布尔值
        - 布尔值只有两个值，主要用于做逻辑判断
        - 使用typeof检查一个布尔值时，会返回Boolean
    - Null 空值
        - Null只有一个值，就是null
        - 这个值专门用来表示一个为空的对象
        - 使用typeof检查一个null值时，会返回object
    - Undefined 未定义
        - Undefined只有一个值，就是undefined
        - 当声明一个变量，但是并不给变量赋值时，它的值就是undefined
        - 使用typeof检查一个undefined时也会返回undefined
    - Object 对象
    - 其中String Number Boolean Null Undefined属于基本数据类型
        而Object属于引用数据类型</code></pre>
<p>数据类型的转换</p>
<pre><code>* 将其他的数据类型转换为String
    - 方式一：
        - 调用被转换数据类型的toString()方法
        - 该方法不会影响到原变量，它会将转换的结果返回
        - 但null和undefined两个值没有toString()方法
            如果调用他们的方法会报错
    - 方式二：
        - 调用String()函数，并将被转换的数据作为参数传递给函数
        - 使用String()函数做强制类型转换时
            - 对于Number和Boolean实际上就是调用的toString()方法
            - 对于null和undefined就不会调用toString()方法
                它会将null直接转换成&quot;null&quot;
                将undefined直接转换成&quot;undefined&quot;

* 将其他的数据类型转换为Number
    - 方式一：
        - 使用Number()函数
            - 字符串 --&gt; 数字
                - 如果是纯数字的字符串，则直接将其转换成数字
                - 如果字符串中有非数字的内容，则转换为NaN
                - 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0
            - 布尔 --&gt; 数字
                - true 转成 1
                - false 转成 0
            - null --&gt; 数字 0
            - undefined --&gt; 数字 NaN
    - 方式二：
        - 这种方式专门用来对付字符串
        - parseInt() 把一个字符串转换成一个整数
            像“070”这样的字符串，有些浏览器会当成8进制来解析，有些会当成10进制来解析
            因此可在其中加入第二个参数来指定数字的进制
        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">&quot;070&quot;</span>;</span><br><span class="line">a=<span class="built_in">parseInt</span>(a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
        - parseFloat() 把一个字符串转换为一个浮点数
* 将其他的数据类型转换为Boolean
    - 使用Boolean()函数
        - 数字--&gt;布尔
            除了0和NaN，其余都是true
        - 字符串--&gt;布尔
            除了空串，其余都是true
        - null和undefined都会转换为false
        - 对象也会转换为true</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/04/Css/Css10/">Css10</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-04
        
    </p>

    

    <!-- Content -->
    <p>CSS中的高度塌陷问题</p>
<pre><code>* 高度塌陷的问题：
    - 在浮动布局中，父元素的高度默认是被子元素撑开的
        当子元素浮动后，其完全脱离文档流，子元素从文档流后将无法撑起父元素的高度
        导致父元素的高度丢失
    - 父元素高度丢失后，其下的元素会自动上移，导致页面的布局混乱
        所以这个问题必须处理</code></pre>
<p>CSS高度塌陷的处理</p>
<pre><code>* BFC（Block Formatting Context）块级格式化环境
    - BFC是CSS中的一个隐含元素，可以为一个元素开启BFC
        开启BFC该元素会变成一个独立的布局区域
    - 元素开启BFC后的特点：
        - 不会被浮动的父元素所覆盖
        - 子元素和父元素外边距不会重叠
        - 可以包含浮动的子元素
    - 可以通过一些特殊的方式来开启元素的BFC：
        - 设置元素的浮动（不推荐）
        - 将元素设置为行内块元素（不推荐）
        - 将元素的overflow属性设置为一个非visible（默认值）的值
            常用的方式 为元素设置overflow:auto或overflow:hidden
* 利用after伪元素
    - 向其塌陷的父元素添加一个after伪元素，在其末尾设置一个空内容
        并将其设置为块元素同时使用clear属性清除浮动元素的影响，以此来撑起父元素的高度</code></pre>
<p>CSS中的clear属性</p>
<pre><code>* 作用：清除浮动元素对当前元素所产生影响
* 可选值：
    - left 清除左侧浮动元素对当前元素的影响
    - right 清除右侧浮动元素对当前元素的影响
    - both 清除两侧中影响最大的那侧
* 原理：设置清除浮动后，浏览器会自动为元素添加一个上外边距
        以使其位置不受其他元素的影响</code></pre>
<p>clearfix</p>
<pre><code>* 设置clearfix类可以同时解决高度塌陷和外边距重叠的问题
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::before,.clearfix::after&#123;</span><br><span class="line">    display:table;</span><br><span class="line">    content:&quot;&quot;;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/03/Css/Css09/">Css09</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-03
        
    </p>

    

    <!-- Content -->
    <p>CSS的浮动</p>
<pre><code>* 通过浮动可以使一个元素向其父元素的左侧或右侧移动
    - 使用float属性来设置元素的浮动
        可选值：
            - none 默认值，元素不浮动
            - left 元素向左移动
            - right 元素向右移动
    - 注意：元素设置浮动以后，水平布局的等式便不需要强制成立
            元素设置浮动后，会完全从文档流中脱离，不再占用文档流的位置
            所以元素下边的还在文档流中的元素会自动向上移动
    - 浮动的特点：
        - 浮动元素会完全脱离文档流，不再占据文档流的位置
        - 设置浮动以后元素会向父元素的左侧或右侧移动
        - 浮动元素默认不会从父元素中移出
        - 浮动元素向左或向右移动时，不会超过它前边的其他浮动元素
        - 如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移
        - 浮动元素不会超过它上边浮动的兄弟元素，最多和它一样高
    - 简单总结：浮动目前来讲它的主要作用就是让页面中的元素可以水平排列
                通过浮动可以制作一些水平方向的布局</code></pre>
<p>CSS中脱离文档流的元素特点</p>
<pre><code>* 块元素：
    - 块元素不再独占一行
    - 脱离文档流后，块元素的宽度和高度都默认被内容撑开
* 行内元素：
    - 行内元素脱离文档流以后会变成块元素，特点和块元素一样
* 脱离文档流以后，不需要再区分快和行内了</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>




<div id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    主题 <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/main.js"></script>


</body>

</html>
