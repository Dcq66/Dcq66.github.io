<html>

<head>
    <meta charset="utf-8">
    
    <title>小戴的学习日记</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/tagplugins.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="小戴的学习日记" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Dcq66.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">小戴的学习日记</h1>
    <p class="lead blog-description">Dcq66.github.io</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/18/Java/Java11-%E7%BB%A7%E6%89%BF/">Java11-继承</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-18
        
    </p>

    

    <!-- Content -->
    <p>继承</p>
<pre><code>* 继承的特点：
    - 子类可以拥有父类的“内容”
    - 子类还可以拥有自己的“专属内容
* 定义父类（基类、超类）的格式（一个普通类的定义）：public class 父类名称&#123;&#125;;
* 定义子类：public class 子类名称 extends 父类名称&#123;&#125;;
* 在父子类的继承关系中，若成员变量/成员方法重名，则创建子类对象时，访问有两种方式：
    - 直接通过子类对象访问成员变量/成员方法：通过谁调用就优先用谁，没有则向上找
    - 间接通过成员方法访问成员变量：该方法属于谁就优先用谁，没有则向上找
    - 注意：无论是成员变量还是成员方法，如果没有都是向上找父类，绝不会向下找子类
* 使用变量：
    - 局部变量：直接写成员变量名
    - 本类的成员变量：this.成员变量名
    - 父类的成员变量：super.成员变量名
* 重写（Override）
    - 概念：在继承关系中方法的名称一样，参数列表也一样
    - 特点：创建的是子类对象则优先使用子类方法
    - 注意事项：
        - 必须保证父子类之间方法的名称、参数列表一样
        - @Override关键字写在方法的前面，可以检测重写是否有效
        - 子类方法的返回值必须小于等于父类方法的返回值范围
        - 子类方法的权限必须大于等于父类方法的权限修饰符
            - public&gt;protected&gt;（default）&gt;private
            - （default）不是关键字，而是什么都不写，留空
* 父子类构造方法的访问特点：
    - 子类构造方法中有一个隐含默认的&quot;super()&quot;调用，所以一定先调用父类构造方法，后执行子类的构造方法
    - 子类构造可以通过super关键字来调用父类重载构造
    - super的父类构造调用必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/18/Java/Java10-static/">Java10-Static</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-18
        
    </p>

    

    <!-- Content -->
    <p>static</p>
<pre><code>* static 静态关键词
* 一旦使用static修饰成员变量/成员方法，那么就成为了静态变量/静态方法，则不属于对象，而是属于类的
    - 如果没有static关键词，那么必须先创建对象，然后通过对象来使用
    - 如果有了static关键词，那么不需要创建对象，可以直接通过类名来使用
    - 无论是成员变量还是成员方法，如果有了static都推荐通过类名称来使用
        - 静态变量：类名称.静态变量
        - 静态方法：类名称.静态方法()
* 注意事项：
    - 静态不能直接访问非静态，因为内存中先有的静态内容，后有的非静态内容
    - 静态方法中不能用this，因为this代表当前对象，通过谁调用的方法，谁就是当前对象
    - 根据类名称访问静态成员变量/成员方法的时候，全程和对象没有关系，只和类有关系
* 静态代码块：static&#123;&#125;;
    - 当第一次用到本类时，静态代码块执行唯一的一次，静态内容总是优先于非静态，
        所以静态代码块比构造方法先执行
    - 用来一次性的对静态成员变量进行赋值</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/17/Java/Java09-%E5%B7%A5%E5%85%B7%E7%B1%BB01/">Java09-工具类01</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-17
        
    </p>

    

    <!-- Content -->
    <p>Scanner</p>
<pre><code>* Scanner类可以实现键盘输入数据到程序中
    - 获取键盘输入的一个int数字:
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">int num&#x3D;sc.nextInt();</span><br></pre></td></tr></table></figure>
    - 获取键盘输入的一个String字符串:
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">String str&#x3D;sc.next();</span><br></pre></td></tr></table></figure></code></pre>
<p>Random</p>
<pre><code>* Random类用来生成随机数字
    - 方法：
        - nextInt() 获取一个随机的int数字，范围是int所有范围，有正负
        - nextInt(int 参数) 获取一个随机的int数字，范围是0-参数，左闭右开区间</code></pre>
<p>ArrayList</p>
<pre><code>* 数组的长度不可以发生改变，但ArrayList集合的长度可以随意改变
* 格式：ArrayList&lt;泛型&gt; 集合名称=new ArrayList&lt;&gt;();
* 对于ArrayList集合来说，有一个尖括号&lt;E&gt;代表泛型
    从JDK1.7+开始，右侧的尖括号内部可以不写内容，但是&lt;&gt;本身还是得写
        - 泛型：装在集合中的所有元素，全都是统一的类型
        - 注意：泛型只能是引用类型，不能是基本类型
* 注意事项：对于ArrayList集合来说，直接打印得到的不是地址值，而是内容
            若内容是空，得到的是空的中括号[]
* 方法：
    - public boolean add(E e) 向集合中添加元素，参数的类型和泛型一致，返回值为Boolean
        - 注意：对于ArrayList集合添加时一定成功的，但对于其他集合就不一定了
    - public E get(int index) 从集合中获取元素，参数是索引编号，返回值是对应位置的元素
    - public E remove(int index) 从集合中删除元素，参数是索引编号，返回值是被删除的元素
    - public int size() 获取集合的长度，返回值是集合的长度
* 如果希望向ArrayList集合当中储存基本数据类型数据，必须使用基本类型对应的“包装类”
    基本类型        包装类（引用类型，包装类都位于java.lang包下）
    byte            Byte
    short           Short
    int             Integer
    long            Long
    float           Float
    double          Double
    char            Character
    boolean         Boolean
    - 从JDK1.5开始，支持自动装箱、自动拆箱
        - 自动装箱：基本类型--&gt;包装类型
        - 自动拆箱：包装类型--&gt;基本类型</code></pre>
<p>String</p>
<pre><code>* java.lang.String类代表字符串
* 字符串的特点：
    - 字符串的内容永不可变
    - 正因为字符串的内容永不可变，所以字符串是共享的
    - 字符串效果上相当于char[]字符数组，但底层原理是byte[]字节数组
* 创建字符串的方法：
    - 构造方法：
        - public String() 创建一个空白字符串，不含有任何内容
        - public String(char[] array) 根据字符数组的内容来创建对应的字符串
        - public String(byte[] array) 根据字节数组的内容来创建对应的字符串
    - 直接创建：
        - String 字符串名称=&quot;字符串内容&quot;
        - 对于引用类型来说，==进行的是地址值的比较
        - 双引号直接创建的字符串在字符串常量池中，new的不在池中
* 方法
    - public boolean equals(Object obj) 参数可以是任意对象，
        只有参数是一个字符串并且内容相同才会返回true，否则返回false
            - 注意事项：
                - 该方法具有对称性，a.equals(b)和b.equals(a)效果一样
                - 若比较双方一个常量一个变量，推荐把常量字符串写在前面
    - public boolean equalsIgnoreCase() 忽略大小写进行比较
    - public int length() 获得字符串长度
    - public String concat(String str) 将当前字符串和参数字符串拼接成一个新的字符串并返回
    - public char charAt(int index) 获得指定索引位置的单个字符
    - public int indexOf(String str) 查找参数字符串在本字符串首次出现的索引位置，若没有则返回-1
    - public String substring(int index) 截取从参数索引位置一直到字符串末尾的字符串并返回
    - public String substring(int begin,int end) 截取从begin开始，到end结束中间的字符串并返回
        - [begin,end)，左闭右开
    - public char[] toCharArray() 将当前字符串拆分为字符数组作为返回值
    - public byte[] getBytes() 将当前字符串拆分为字节数组作为返回值
    - public String replace(CharSequence oldString,CharSequence newString)
        - 将所有出现的老字符串替换为新的字符串并返回替换之后的新字符串
     -public String[] split(String regex) 按照参数的规则将字符串切分为若干部分
        - 注意事项：
            - split方法的参数是一个“正则表达式“
            - 若按照英文句点切分，必须写&quot;\\.&quot;</code></pre>
<p>Arrays</p>
<pre><code>* Arrays是一个与数组相关的工具类
* 方法：
    - public static String toString(数组) 将参数数组变成字符串
    - public static void sort(数组) 按照默认升序对数组的元素进行排序
        - 若是数值，sort默认按照升序从小到大
        - 若是字符串，sort默认按照字母从小到大
        - 若是自定义的类型，那么这个自定义的类型需要有Comparable或者Comparator接口的支持</code></pre>
<p>Math</p>
<pre><code>* Math类是一个与数学相关的工具类
* 方法：
    - public static double abs(double num) 获取绝对值
    - public static double ceil(double num) 向上取整
    - public static double floor(double num) 向下取整
    - public static long round(double num) 四舍五入
    - Math.PI代表圆周率常量</code></pre>
<p>Date</p>
<pre><code>* Date类是一个与日期相关的工具类
* 方法：
    - Date类的带参构造方法：Date(long date)
        - 传入毫秒值，将毫秒转换为Date日期
    - Date类的无参构造方法：Date(long date)
        - 获取当前系统的日期和时间</code></pre>
<p>DateFormat</p>
<pre><code>* DateFormat类是日期/时间格式化子类的抽象类
* 作用：格式化（日期--&gt;文本） 解析（文本--&gt;日期）
* DateFormat类是一个抽象类，所以得通过它的子类SimpleDateFormat来使用它的方法
* 方法
    - String format(Date date) 按照指定的模式把Date日期格式化为符合模式的字符串
    - Date parse(String source) 把符合模式的字符串解析为Date日期
        - 注意事项：
            - 该方法声明了一个异常，使用时要么需要throw抛出异常，要么try...catch自己处理这个异常</code></pre>
<p>SimpleDateFormat 类</p>
<pre><code>* 构造方法：SimpleDateFormat(String pattern) 用给定的模式和默认语言环境构造SimpleDateFormat
    - 参数：传递指定的模式
    - 模式（区分大小写）：
        - y     年
        - M     月
        - d     日
        - H     时
        - m     分
        - s     秒
        - 将模式按照自己的格式组合起来即可，如：&quot;yyyy-MM-dd HH:mm:ss&quot;或&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;
        - 注意：模式中字母不可以随意改动，连接字母的符号可以改变</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/17/Java/Java08-%E5%B0%81%E8%A3%85/">Java08-封装</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-17
        
    </p>

    

    <!-- Content -->
    <p>封装</p>
<pre><code>* 封装就是将一些细节信息隐藏起来，对于外界不可见
* 封装性在Java中的体现：
    - 方法就是一种封装
    - 关键字private也是一种封装
        - 一旦使用关键字private对成员变量进行修饰，那么本类当中仍然可以随意访问
            但超出本类范围之外就不能再直接访问了
        - 因此我们可以采取间接访问private成员变量的方法，就是定义一对Getter/Setter方法</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/16/Java/Java07-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">Java07—类和对象</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-16
        
    </p>

    

    <!-- Content -->
    <p>类和对象</p>
<pre><code>* 类：是一组相关属性和行为的集合，可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物
    - 属性：该事物的状态信息
    - 行为：该事物能够做什么
* 对象：是一类事物的具体体现，对象是类的一个实例，必然具备该类事物的属性和行为
* 类与对象的关系：
    - 类是对一类事物的描述，是抽象的
    - 对象是一类事物的实例，是具体的
    - 类是对象的模板，对象是类的实体
* 定义一个类由两个部分组成：属性和行为
    - 成员变量（属性）
    - 成员方法（行为）
    - 注意事项：
        - 成员变量是直接定义在类当中的，在方法外边
        - 成员方法不用写static关键字
* 通常情况下，一个类并不能直接使用，需要根据类创建一个对象才能使用
    - 导包
        - 引入需要使用的类
        - 格式：import 包名称.类名称
        - 需要引入的类和当前类属于同一个包时，就不需要导包
    - 创建格式：类名称 对象名=new 类名称()
    - 使用：
        - 使用成员变量：对象名.成员变量名
        - 使用成员方法：对象名.成员方法名(),有参则在括号中加入参数
        - 注意：若成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样
* 局部变量和成员变量
    - 定义的位置不一样：
        - 局部变量：在方法的内部
        - 成员变量：在方法的外部，直接写在类中
    - 作用范围不一样：
        - 局部变量：只能在方法中使用
        - 成员变量：整个类全部都可以通用
    - 默认值不一样：
        - 局部变量：没有默认值，如果想要使用必须手动进行赋值
        - 成员变量：有默认值，规则和数组一样
    - 内存的位置不一样：
        - 局部变量：栈内存
        - 成员变量：堆内存
    - 生命周期不一样
        - 局部变量：随着方法进栈而诞生，随着方法出栈消失
        - 成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失
* 匿名对象：只有右边的对象，没有左边的名字和赋值运算符，即new 类名称();
    - 注意事项：匿名对象创建之后只能使用一次
    - 使用建议：如果确定有一个对象只需要使用唯一的一次，就可以使用匿名对象</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/15/Java/Java06-%E5%86%85%E5%AD%98/">Java06——内存</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-15
        
    </p>

    

    <!-- Content -->
    <p>内存</p>
<pre><code>* Java内存需要划分为5个部分：
    - 栈（Stack）：存放的都是方法中的局部变量。方法的运行一定在栈当中运行
        - 局部变量：方法的参数，或是方法内部的变量
        - 作用域：一旦超出作用域立刻从栈内存中消失
    - 堆（Heap）：凡是new出来的东西都在堆内存中
        - 堆内存里面的东西都有一个地址值（16进制）
        - 堆内存中的数据都有一个默认值：
            - 整数类型则默认为0
            - 浮点类型则默认为0.0
            - 字符类型则默认为&#39;\u0000&#39;
            - 如果是布尔类型则默认为false
            - 如果是引用类型则默认为null
    - 方法区（Method Area）：储存.class相关信息，包含方法的信息
    - 本地方法栈（Native Method Stack）：与操作系统有关
    - 寄存器（pc Register）：与CPU有关</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/15/Java/Java04-%E6%96%B9%E6%B3%95/">Java05——方法</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-15
        
    </p>

    

    <!-- Content -->
    <p>方法</p>
<pre><code>* 定义方法的完整格式：
    修饰符 返回值类型 方法名称(参数类型 参数名称, ....)&#123;
        方法体
        return 返回值
    &#125;
    - 修饰符：初学阶段的固定写法为public static
    - 返回值类型：方法最终产生的数据结果是什么类型
    - 方法名称：方法的名字，一般都是小驼峰写法
    - 参数类型：传入方法中的数据类型
    - 参数名字（形参）：进入方法的数据对应的变量名称
    -方法体：方法所执行的代码
    - return：
        - 停止当前方法
        - 将后面的返回值还给调用处
        - 注意：return后面的返回值类型必须和方法名称前面的返回值类型一致
    - 返回值：方法执行后最终产生的数据结果
* 有参数：小括号中有内容，当一个方法需要一些数据条件才能完成任务时，就是有参
* 无参数：小括号中没有内容，当一个方法不需要任何数据条件就能完成任务时，就是无参
* 使用方法的注意事项：
    - 方法应该定义在类当中，不能在方法中定义方法，即方法不能嵌套
    - 多个方法定义的前后顺序无所谓
    - 方法定义之后不会立即执行，只有当调用该方法时才会执行
    - 如果方法有返回值，那么必须写上“return 返回值;”
    - 对于一个没有设置返回值（即void）的方法，可以不写return，若写上return就不能加上返回值，
        即只能return自身
    - 一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行，两个return不能连写
* 方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样
    - 好处：只需要使用一个方法即可实现多个类似的功能
    - 方法重载只与以下因素有关：
        - 参数个数
        - 参数类型
        - 参数的多类型顺序不同
    - 方法重载与以下因素无关：
        - 参数名称
        - 返回值类型....
* 构造方法
    - 专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法
    - 格式：public 类名称（参数类型 参数名称）&#123;方法体&#125;
    - 注意事项：
        - 构造方法的名称必须和所在类的名称完全一致
        - 构造方法不用写返回值类型，连void都不用写
        - 构造方法不能return一个具体的返回值
        - 如果没有编写构造方法，那么编译器会默认赠送一个构造方法，没有参数、方法体，什么事都不做
        - 一旦编写了至少一个构造方法，那么编译器将不在赠送
        - 构造方法也可以重载</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/14/ajax/ajax01/">Ajax01</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-14
        
    </p>

    

    <!-- Content -->
    <p>JS 原生 ajax</p>
<pre><code>* HTTP(hypertext transport protocol)协议(超文本传输协议)，
    协议详细规定了浏览器和万维网服务器之间互相通信的规则
* 请求报文和响应报文格式与参数
    - 行
    - 头
    - 体
* 创建ajax
    1.创建对象
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr&#x3D;new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
    2.初始化，设置请求方法和url
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;GET&quot;,&quot;style.json&quot;);</span><br><span class="line">&lt;!-- xhr.open(&quot;POST&quot;,&quot;style.json&quot;); --&gt;</span><br></pre></td></tr></table></figure>
    3.发送
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
    4.事件绑定，处理服务端返回的结果
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange&#x3D;function()&#123;</span><br><span class="line">    &lt;!-- 判断状态(因为服务器返回了所有的结果) --&gt;</span><br><span class="line">    if(xhr.readyState&#x3D;&#x3D;&#x3D;4)&#123;</span><br><span class="line">        &lt;!-- 判断响应状态码 --&gt;</span><br><span class="line">        if(xhr.status&gt;&#x3D;200&amp;&amp;xhr.status&lt;&#x3D;300||xhr.status&#x3D;&#x3D;&#x3D;304&gt;)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>jquery ajax</p>
<pre><code>* 创建ajax，直接调用jquery中的.ajax()方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;&quot;;</span><br><span class="line">    type:&quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/08/JavaScript/tools/">Tools</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-08
        
    </p>

    

    <!-- Content -->
    <p>自定义的函数</p>
<pre><code>* 定义一个函数用来判断一个元素中是否有指定的class属性值
    有则返回 true 反之返回 false
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">参数：</span><br><span class="line">    obj 要添加 class 属性的元素</span><br><span class="line">    cn 要添加的 class 属性值 </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">function hasClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 创建一个正则表达式</span><br><span class="line">var reg&#x3D;new RegExp(&quot;\\b&quot;+cn+&quot;\\b&quot;);</span><br><span class="line">return reg.test(obj.className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来向一个元素中添加指定的 class 属性值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">参数：</span><br><span class="line">    obj 要添加 class 属性的元素</span><br><span class="line">    cn 要添加的 class 属性值 </span><br><span class="line">--&gt;</span><br><span class="line">function addClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 检查 obj 中是否含有 cn</span><br><span class="line">if(!hasClass(obj,cn))&#123;</span><br><span class="line">obj.className+&#x3D;&quot;&quot;+cn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来删除一个元素中指定的 class 属性值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--         </span><br><span class="line">参数：</span><br><span class="line">obj 要添加 class 属性的元素</span><br><span class="line">cn 要添加的 class 属性值</span><br><span class="line">--&gt;</span><br><span class="line">function removeClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 创建一个正则表达式</span><br><span class="line">var reg&#x3D;new RegExp(&quot;\\b&quot;+cn+&quot;\\b&quot;);</span><br><span class="line">&#x2F;&#x2F; 删除 class</span><br><span class="line">obj.className&#x3D;obj.className.replace(reg,&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来切换一个类,如果元素中有该类则删除,如果元素中没有该类则添加
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--     </span><br><span class="line">参数：</span><br><span class="line">obj 要添加 class 属性的元素</span><br><span class="line">cn 要添加的 class 属性值</span><br><span class="line"> --&gt;</span><br><span class="line">function toggleClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 检查 obj 中是否含有 cn</span><br><span class="line">if(hasClass(obj,cn))&#123;</span><br><span class="line">&#x2F;&#x2F; 有则删除</span><br><span class="line">removeClass(obj,cn);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#x2F;&#x2F; 没有则添加</span><br><span class="line">addClass(obj,cn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/05/JavaScript/JavaScript11/">JavaScript11</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-05
        
    </p>

    

    <!-- Content -->
    <p>计时器</p>
<pre><code>* setInterval()
    - 定时调用
    - 可以将一个函数每隔一段时间执行一次
    - 参数：
        1.回调函数，该函数每隔一段时间被调用一次
        2.每次调用间隔的时间，单位是毫秒
    - 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识
* setTimeout()
    - 延时调用
    - 延时调用一个函数不会马上执行，而是隔一段时间后再执行，而且只会执行一次
    - 参数：
        1.回调函数
        2.执行之前间隔的时间，单位是毫秒
    - 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识
* clearInterval()
    - 可以用来关闭一个定时器
    - 可以接收任意参数，当一个定时器的标识作为参数，这样将关闭标识对应的定时器
        若参数不是一个有效的标识则什么都不做</code></pre>
<p>JSON</p>
<pre><code>* JavaScript Object Notation JS对象表示法
* JS中的对象只有JS自己认识，其他语言都不认识
* JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言识别
    并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互
* JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须要加双引号
* JSON中允许的值：
    - 字符串
    - 数值
    - 布尔值
    - null
    - 对象
    - 数组
* 将JSON字符串转换为JS中的对象
    - 在JS中为我们提供了一个工具类就叫JSON，这个对象可以帮助我们将一个JSON转换为JS对象
        也可以将JS对象转换为JSON
    - JSON--&gt;JS
        - JSON.parse()
            - 将一个JSON转换为JS对象
            - 需要一个JSON字符串作为参数，会将该字符串转换为JS对象并将其作为返回值返回
    - JS--&gt;JSON
        - JSON.stringify()
            - 将一个JS转换为JSON对象
            - 需要一个JS对象作为参数，会将该对象转换为JSON字符串并将其作为返回值返回
    - JSON这个对象在IE7及以下的浏览器中不支持，如果需要兼容IE7及以下的浏览器的JSON操作
        可以通过引入一个外部的JS文件来处理</code></pre>
<p>闭包</p>
<pre><code>* 如何产生闭包？
    - 当一个嵌套的内部子函数引用了嵌套的外部父函数的变量（函数）时，就产生了闭包
* 闭包到底是什么？
    - 闭包是嵌套的内部函数
    - 包含被引用变量（函数）的对象
    - 注意：闭包存在于嵌套的内部函数中
* 产生闭包的条件
    - 函数嵌套
    - 内部函数引用了外部函数的数据（变量/函数 ）</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>




<div id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    主题 <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/main.js"></script>


</body>

</html>
