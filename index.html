<html>

<head>
    <meta charset="utf-8">
    
    <title>小戴的学习日记</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/tagplugins.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="小戴的学习日记" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Dcq66.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">小戴的学习日记</h1>
    <p class="lead blog-description">Dcq66.github.io</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/17/Java/Java10-%E5%AD%97%E7%AC%A6%E4%B8%B2/">Java10-字符串</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-17
        
    </p>

    

    <!-- Content -->
    <p>字符串</p>
<pre><code>* java.lang.String类代表字符串
* 字符串的特点：
    - 字符串的内容永不可变
    - 正因为字符串的内容永不可变，所以字符串是共享的
    - 字符串效果上相当于char[]字符数组，但底层原理是byte[]字节数组</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/17/Java/Java09-%E5%B7%A5%E5%85%B7%E7%B1%BB/">Java09-工具类</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-17
        
    </p>

    

    <!-- Content -->
    <p>Scanner</p>
<pre><code>* Scanner类可以实现键盘输入数据到程序中
    - 获取键盘输入的一个int数字:
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">int num&#x3D;sc.nextInt();</span><br></pre></td></tr></table></figure>
    - 获取键盘输入的一个String字符串:
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">String str&#x3D;sc.next();</span><br></pre></td></tr></table></figure></code></pre>
<p>Random</p>
<pre><code>* Random类用来生成随机数字
    - 方法：
        - nextInt() 获取一个随机的int数字，范围是int所有范围，有正负
        - nextInt(int 参数) 获取一个随机的int数字，范围是0-参数，左闭右开区间</code></pre>
<p>ArrayList</p>
<pre><code>* 数组的长度不可以发生改变，但ArrayList集合的长度可以随意改变
* 格式：ArrayList&lt;泛型&gt; 集合名称=new ArrayList&lt;&gt;();
* 对于ArrayList集合来说，有一个尖括号&lt;E&gt;代表泛型
    从JDK1.7+开始，右侧的尖括号内部可以不写内容，但是&lt;&gt;本身还是得写
        - 泛型：装在集合中的所有元素，全都是统一的类型
        - 注意：泛型只能是引用类型，不能是基本类型
* 注意事项：对于ArrayList集合来说，直接打印得到的不是地址值，而是内容
            若内容是空，得到的是空的中括号[]
* 方法：
    - public boolean add(E e) 向集合中添加元素，参数的类型和泛型一致，返回值为Boolean
        - 注意：对于ArrayList集合添加时一定成功的，但对于其他集合就不一定了
    - public E get(int index) 从集合中获取元素，参数是索引编号，返回值是对应位置的元素
    - public E remove(int index) 从集合中删除元素，参数是索引编号，返回值是被删除的元素
    - public int size() 获取集合的长度，返回值是集合的长度
* 如果希望向ArrayList集合当中储存基本数据类型数据，必须使用基本类型对应的“包装类”
    基本类型        包装类（引用类型，包装类都位于java.lang包下）
    byte            Byte
    short           Short
    int             Integer
    long            Long
    float           Float
    double          Double
    char            Character
    boolean         Boolean
    - 从JDK1.5开始，支持自动装箱、自动拆箱
        - 自动装箱：基本类型--&gt;包装类型
        - 自动拆箱：包装类型--&gt;基本类型</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/17/Java/Java08-%E5%B0%81%E8%A3%85%E4%B8%8Ethis/">Java08-封装与This</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-17
        
    </p>

    

    <!-- Content -->
    <p>封装</p>
<pre><code>* 封装就是将一些细节信息隐藏起来，对于外界不可见
* 封装性在Java中的体现：
    - 方法就是一种封装
    - 关键字private也是一种封装
        - 一旦使用关键字private对成员变量进行修饰，那么本类当中仍然可以随意访问
            但超出本类范围之外就不能再直接访问了
        - 因此我们可以采取间接访问private成员变量的方法，就是定义一对Getter/Setter方法</code></pre>
<p>this</p>
<pre><code>* 当方法的局部变量和类的成员变量重名时，根据“就近原则”，优先使用局部变量
    若需要在方法中访问成员变量可以使用this.成员变量名
* 通过谁调用的方法，this就是谁</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/16/Java/Java07-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">Java07—类和对象</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-16
        
    </p>

    

    <!-- Content -->
    <p>类和对象</p>
<pre><code>* 类：是一组相关属性和行为的集合，可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物
    - 属性：该事物的状态信息
    - 行为：该事物能够做什么
* 对象：是一类事物的具体体现，对象是类的一个实例，必然具备该类事物的属性和行为
* 类与对象的关系：
    - 类是对一类事物的描述，是抽象的
    - 对象是一类事物的实例，是具体的
    - 类是对象的模板，对象是类的实体
* 定义一个类由两个部分组成：属性和行为
    - 成员变量（属性）
    - 成员方法（行为）
    - 注意事项：
        - 成员变量是直接定义在类当中的，在方法外边
        - 成员方法不用写static关键字
* 通常情况下，一个类并不能直接使用，需要根据类创建一个对象才能使用
    - 导包
        - 引入需要使用的类
        - 格式：import 包名称.类名称
        - 需要引入的类和当前类属于同一个包时，就不需要导包
    - 创建格式：类名称 对象名=new 类名称()
    - 使用：
        - 使用成员变量：对象名.成员变量名
        - 使用成员方法：对象名.成员方法名(),有参则在括号中加入参数
        - 注意：若成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样
* 局部变量和成员变量
    - 定义的位置不一样：
        - 局部变量：在方法的内部
        - 成员变量：在方法的外部，直接写在类中
    - 作用范围不一样：
        - 局部变量：只能在方法中使用
        - 成员变量：整个类全部都可以通用
    - 默认值不一样：
        - 局部变量：没有默认值，如果想要使用必须手动进行赋值
        - 成员变量：有默认值，规则和数组一样
    - 内存的位置不一样：
        - 局部变量：栈内存
        - 成员变量：堆内存
    - 生命周期不一样
        - 局部变量：随着方法进栈而诞生，随着方法出栈消失
        - 成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失
* 匿名对象：只有右边的对象，没有左边的名字和赋值运算符，即new 类名称();
    - 注意事项：匿名对象创建之后只能使用一次
    - 使用建议：如果确定有一个对象只需要使用唯一的一次，就可以使用匿名对象</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/15/Java/Java06-%E5%86%85%E5%AD%98/">Java06——内存</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-15
        
    </p>

    

    <!-- Content -->
    <p>内存</p>
<pre><code>* Java内存需要划分为5个部分：
    - 栈（Stack）：存放的都是方法中的局部变量。方法的运行一定在栈当中运行
        - 局部变量：方法的参数，或是方法内部的变量
        - 作用域：一旦超出作用域立刻从栈内存中消失
    - 堆（Heap）：凡是new出来的东西都在堆内存中
        - 堆内存里面的东西都有一个地址值（16进制）
        - 堆内存中的数据都有一个默认值：
            - 整数类型则默认为0
            - 浮点类型则默认为0.0
            - 字符类型则默认为&#39;\u0000&#39;
            - 如果是布尔类型则默认为false
            - 如果是引用类型则默认为null
    - 方法区（Method Area）：储存.class相关信息，包含方法的信息
    - 本地方法栈（Native Method Stack）：与操作系统有关
    - 寄存器（pc Register）：与CPU有关</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/15/Java/Java04-%E6%96%B9%E6%B3%95/">Java05——方法</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-15
        
    </p>

    

    <!-- Content -->
    <p>方法</p>
<pre><code>* 定义方法的完整格式：
    修饰符 返回值类型 方法名称(参数类型 参数名称, ....)&#123;
        方法体
        return 返回值
    &#125;
    - 修饰符：初学阶段的固定写法为public static
    - 返回值类型：方法最终产生的数据结果是什么类型
    - 方法名称：方法的名字，一般都是小驼峰写法
    - 参数类型：传入方法中的数据类型
    - 参数名字（形参）：进入方法的数据对应的变量名称
    -方法体：方法所执行的代码
    - return：
        - 停止当前方法
        - 将后面的返回值还给调用处
        - 注意：return后面的返回值类型必须和方法名称前面的返回值类型一致
    - 返回值：方法执行后最终产生的数据结果
* 有参数：小括号中有内容，当一个方法需要一些数据条件才能完成任务时，就是有参
* 无参数：小括号中没有内容，当一个方法不需要任何数据条件就能完成任务时，就是无参
* 使用方法的注意事项：
    - 方法应该定义在类当中，不能在方法中定义方法，即方法不能嵌套
    - 多个方法定义的前后顺序无所谓
    - 方法定义之后不会立即执行，只有当调用该方法时才会执行
    - 如果方法有返回值，那么必须写上“return 返回值;”
    - 对于一个没有设置返回值（即void）的方法，可以不写return，若写上return就不能加上返回值，
        即只能return自身
    - 一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行，两个return不能连写
* 方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样
    - 好处：只需要使用一个方法即可实现多个类似的功能
    - 方法重载只与以下因素有关：
        - 参数个数
        - 参数类型
        - 参数的多类型顺序不同
    - 方法重载与以下因素无关：
        - 参数名称
        - 返回值类型....
* 构造方法
    - 专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法
    - 格式：public 类名称（参数类型 参数名称）&#123;方法体&#125;
    - 注意事项：
        - 构造方法的名称必须和所在类的名称完全一致
        - 构造方法不用写返回值类型，连void都不用写
        - 构造方法不能return一个具体的返回值
        - 如果没有编写构造方法，那么编译器会默认赠送一个构造方法，没有参数、方法体，什么事都不做
        - 一旦编写了至少一个构造方法，那么编译器将不在赠送
        - 构造方法也可以重载</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/14/ajax/ajax01/">Ajax01</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-14
        
    </p>

    

    <!-- Content -->
    <p>JS 原生 ajax</p>
<pre><code>* HTTP(hypertext transport protocol)协议(超文本传输协议)，
    协议详细规定了浏览器和万维网服务器之间互相通信的规则
* 请求报文和响应报文格式与参数
    - 行
    - 头
    - 体
* 创建ajax
    1.创建对象
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr&#x3D;new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
    2.初始化，设置请求方法和url
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;GET&quot;,&quot;style.json&quot;);</span><br><span class="line">&lt;!-- xhr.open(&quot;POST&quot;,&quot;style.json&quot;); --&gt;</span><br></pre></td></tr></table></figure>
    3.发送
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
    4.事件绑定，处理服务端返回的结果
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange&#x3D;function()&#123;</span><br><span class="line">    &lt;!-- 判断状态(因为服务器返回了所有的结果) --&gt;</span><br><span class="line">    if(xhr.readyState&#x3D;&#x3D;&#x3D;4)&#123;</span><br><span class="line">        &lt;!-- 判断响应状态码 --&gt;</span><br><span class="line">        if(xhr.status&gt;&#x3D;200&amp;&amp;xhr.status&lt;&#x3D;300||xhr.status&#x3D;&#x3D;&#x3D;304&gt;)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>jquery ajax</p>
<pre><code>* 创建ajax，直接调用jquery中的.ajax()方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;&quot;;</span><br><span class="line">    type:&quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/08/JavaScript/tools/">Tools</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-08
        
    </p>

    

    <!-- Content -->
    <p>自定义的函数</p>
<pre><code>* 定义一个函数用来判断一个元素中是否有指定的class属性值
    有则返回 true 反之返回 false
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">参数：</span><br><span class="line">    obj 要添加 class 属性的元素</span><br><span class="line">    cn 要添加的 class 属性值 </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">function hasClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 创建一个正则表达式</span><br><span class="line">var reg&#x3D;new RegExp(&quot;\\b&quot;+cn+&quot;\\b&quot;);</span><br><span class="line">return reg.test(obj.className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来向一个元素中添加指定的 class 属性值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">参数：</span><br><span class="line">    obj 要添加 class 属性的元素</span><br><span class="line">    cn 要添加的 class 属性值 </span><br><span class="line">--&gt;</span><br><span class="line">function addClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 检查 obj 中是否含有 cn</span><br><span class="line">if(!hasClass(obj,cn))&#123;</span><br><span class="line">obj.className+&#x3D;&quot;&quot;+cn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来删除一个元素中指定的 class 属性值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--         </span><br><span class="line">参数：</span><br><span class="line">obj 要添加 class 属性的元素</span><br><span class="line">cn 要添加的 class 属性值</span><br><span class="line">--&gt;</span><br><span class="line">function removeClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 创建一个正则表达式</span><br><span class="line">var reg&#x3D;new RegExp(&quot;\\b&quot;+cn+&quot;\\b&quot;);</span><br><span class="line">&#x2F;&#x2F; 删除 class</span><br><span class="line">obj.className&#x3D;obj.className.replace(reg,&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来切换一个类,如果元素中有该类则删除,如果元素中没有该类则添加
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--     </span><br><span class="line">参数：</span><br><span class="line">obj 要添加 class 属性的元素</span><br><span class="line">cn 要添加的 class 属性值</span><br><span class="line"> --&gt;</span><br><span class="line">function toggleClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 检查 obj 中是否含有 cn</span><br><span class="line">if(hasClass(obj,cn))&#123;</span><br><span class="line">&#x2F;&#x2F; 有则删除</span><br><span class="line">removeClass(obj,cn);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#x2F;&#x2F; 没有则添加</span><br><span class="line">addClass(obj,cn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/05/JavaScript/JavaScript11/">JavaScript11</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-05
        
    </p>

    

    <!-- Content -->
    <p>计时器</p>
<pre><code>* setInterval()
    - 定时调用
    - 可以将一个函数每隔一段时间执行一次
    - 参数：
        1.回调函数，该函数每隔一段时间被调用一次
        2.每次调用间隔的时间，单位是毫秒
    - 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识
* setTimeout()
    - 延时调用
    - 延时调用一个函数不会马上执行，而是隔一段时间后再执行，而且只会执行一次
    - 参数：
        1.回调函数
        2.执行之前间隔的时间，单位是毫秒
    - 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识
* clearInterval()
    - 可以用来关闭一个定时器
    - 可以接收任意参数，当一个定时器的标识作为参数，这样将关闭标识对应的定时器
        若参数不是一个有效的标识则什么都不做</code></pre>
<p>JSON</p>
<pre><code>* JavaScript Object Notation JS对象表示法
* JS中的对象只有JS自己认识，其他语言都不认识
* JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言识别
    并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互
* JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须要加双引号
* JSON中允许的值：
    - 字符串
    - 数值
    - 布尔值
    - null
    - 对象
    - 数组
* 将JSON字符串转换为JS中的对象
    - 在JS中为我们提供了一个工具类就叫JSON，这个对象可以帮助我们将一个JSON转换为JS对象
        也可以将JS对象转换为JSON
    - JSON--&gt;JS
        - JSON.parse()
            - 将一个JSON转换为JS对象
            - 需要一个JSON字符串作为参数，会将该字符串转换为JS对象并将其作为返回值返回
    - JS--&gt;JSON
        - JSON.stringify()
            - 将一个JS转换为JSON对象
            - 需要一个JS对象作为参数，会将该对象转换为JSON字符串并将其作为返回值返回
    - JSON这个对象在IE7及以下的浏览器中不支持，如果需要兼容IE7及以下的浏览器的JSON操作
        可以通过引入一个外部的JS文件来处理</code></pre>
<p>闭包</p>
<pre><code>* 如何产生闭包？
    - 当一个嵌套的内部子函数引用了嵌套的外部父函数的变量（函数）时，就产生了闭包
* 闭包到底是什么？
    - 闭包是嵌套的内部函数
    - 包含被引用变量（函数）的对象
    - 注意：闭包存在于嵌套的内部函数中
* 产生闭包的条件
    - 函数嵌套
    - 内部函数引用了外部函数的数据（变量/函数 ）</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/04/JavaScript/JavaScript10/">JavaScript10</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-04
        
    </p>

    

    <!-- Content -->
    <p>方法、属性与事件</p>
<pre><code>* setCapture() 设置该元素对事件进行捕获
* releaseCapture() 取消对事件的捕获
* wheelDelta属性 可以获取鼠标滚轮滚动的方向
    - 向上滚 120 向下滚 -120
    - 用正负来判断滚动方向
    - 火狐中不支持
* detail属性() 可以获取鼠标滚轮滚动的方向，火狐支持
* 键盘事件
    - 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document
    - onkeydown 按键被按下
        - 若一直按着绑定该事件的按键则事件会一直触发
        - 该事件连续触发时，第一次和第二次之间会间隔稍微长一些，其它的会非常的快，这种设计是为了防止误操作
    - onkeyup 按键被松开
    - keyCode 获取按键的编码，通过它可以判断哪个按键被按下
        - 37 左
        - 38 上
        - 39 右
        - 40 下
    - altkey ctrlkey shiftkey
        - 判断alt ctrl shift是否被按下，按下则返回true 反之返回false</code></pre>
<p>BOM</p>
<pre><code>* 浏览器对象模型
* BOM可以使我们通过JS来操作浏览器
* 在BOM中提供了一组对象用来完成对浏览器的操作
* BOM对象
    - Window
        - 代表整个浏览器的窗口，同时window也是网页中的全局对象
    - Navigator
        - 代表当前浏览器的信息，可用来识别不同的浏览器
        - 由于历史原因，Navigator对象中的大部分属性已经不能帮助我们识别浏览器了
        - 一般我们会使用userAgent来判断浏览器的信息，userAgent是一个字符串，
            这个字符串包含有用来描述浏览器信息的内容，不同的浏览器有不同的userAgent
                但在IE11中已经将微软和IE有关的标识都去除了，所以基本不能通过userAgent来识别是否为IE11了
        - 我们可以通过ActiveXObject来判断一个浏览器是否为IE11
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var ua&#x3D;navigator.userAgent;</span><br><span class="line">&lt;!-- 通过正则表达式来检查 --&gt;</span><br><span class="line">if(&#x2F;firefox&#x2F;i.test(ua))&#123;</span><br><span class="line">    alert(&quot;火狐浏览器&quot;);</span><br><span class="line">&#125;else if(&#x2F;chrome&#x2F;i.test(ua))&#123;</span><br><span class="line">    alert(&quot;Chrome浏览器&quot;);</span><br><span class="line">&#125;else if(&#x2F;msie&#x2F;i.test(ua))&#123;</span><br><span class="line">    alert(&quot;IE浏览器&quot;);</span><br><span class="line">&#125;else if(&quot;ActiveXObject&quot; in window)&#123;</span><br><span class="line">    alert(&quot;IE11&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - Location
        - 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息或者操作浏览器跳转页面
        - 若直接输出location则可以获取到当前浏览器地址栏的信息（当前浏览器的完整路径）
            若直接将location属性修改为其他路径则页面会自动跳转到该路径，并且会生相应的历史记录
        - assign() 跳转到其他的页面，作用和直接修改location属性一样
        - reload() 重新加载当前页面，作用和刷新按钮一样
            - 若在方法中传递一个true作为参数，则会强制清空缓存刷新页面
        - replace() 使用一个新的页面替换当前页面，调用完毕后也会跳转页面，
            不会生成历史记录，也不能使用回退按钮回退
    - History
        - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
            但由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
                而且该操作只在当次访问时有效
        - length属性 可以获取到当前访问的链接数量
        - back() 回退到上一个页面，作用和浏览器的回退按钮一样
        - forward() 跳转到下一个页面，作用和浏览器的前进按钮一样
        - go()
            - 跳转到指定的页面
            - 需要一个整数作为参数：
                1：表示向前跳转一个页面，相当于forward()
                2：表示向前跳转两个页面
                -1：表示向后回退一个页面
                -2：表示向后回退两个页面
    - Screen
        - 代表用户的屏幕信息，通过该对象可以获取到用户显示器的相关信息
    - 这些BOM对象在浏览器中都是作为window对象的属性保存的，
        可以通过window对象来使用，也可以直接使用</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>




<div id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    主题 <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/main.js"></script>


</body>

</html>
