<html>

<head>
    <meta charset="utf-8">
    
    <title>小戴的学习日记</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/tagplugins.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="小戴的学习日记" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Dcq66.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">小戴的学习日记</h1>
    <p class="lead blog-description">Dcq66.github.io</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/12/11/Java/Java29-Properties/">Java29-Properties</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-12-11
        
    </p>

    

    <!-- Content -->
    <p>Properties</p>
<pre><code>* Properties集合，是Hashtable的子类
    - 该类表示了一个持久的属性集，Properties可保存在流中或从流中加载，且是唯一一个和IO流相结合的集合
        - 可使用Properties集合中的store方法，把集合中的临时数据持久化写入到硬盘中存储
        - 可使用Properties集合中的load方法，把硬盘中保存的文件（键值对）读取到集合中使用
    - 该集合中每一个键值key和value都默认是字符串
    - 常用方法：
        - Object setProperty(String key,String value) 相当于Hashtable的put方法
        - String getProperty(String key) 通过key找到其对应的值，相当于Map的get(key)方法
        - Set&lt;String&gt; stringPropertyName() 返回该集合的中键值集合，相当于Map中的keySet方法
    - 使用Properties集合中的store方法，把集合中的临时数据持久化写入到硬盘中存储
        - void store(OutputStream out,String comments)
        - void store(Writer writer,String comments)
        - 参数：
            - OutputStream out：字节输出流，不能写入中文
            - Writer writer：字符输出流，可以写入中文
            - String comments：注释，一般用来说明保存的文件是做什么用的，不能写入中文，一般使用空字符串
        - 使用步骤：
            - 1.创建Properties集合对象，添加数据
            - 2.创建字节输出流/字符输出流对象，构造方法中绑定要输出的目的文件
            - 3.使用store方法，把集合中的临时数据持久化的写入到硬盘中储存
            - 4.释放资源
    - 使用Properties集合中的load方法，把硬盘中保存的文件（键值对）读取到集合中使用
        - void load(InputStream inStream)
        - void load(Reader reader)
        - 参数：
            - InputStream inStream：字节输入流，不能读取含有中文的键值对
            - Reader reader：字符输出流，可以读取含有中文的键值对
        - 注意：
            - 存储键值对的文件中，键与值默认的连接符号可以使用=，空格（其他符号）
            - 存储键值对的文件中，可以使用#进行注释，被注释的键值不会再被读取
            - 存储键值对的文件中，键值对都默认是字符串，不用再加引号</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/12/10/Java/Java28-IO/">Java28-IO流</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-12-10
        
    </p>

    

    <!-- Content -->
    <p>IO 流</p>
<pre><code>* IO流的顶级父类们：
    - 字节流：字节输入流与字节输出流
    - 字符流：字符输入流与字符输出流</code></pre>
<p>字节流</p>
<pre><code>* OutputStream：字节输出流，该抽象类是表示输出字节流的所有类的超类
* OutputStream中定义了一些子类共性的方法：
    - public void close() 关闭此输出流并释放与此流相关联的任何系统资源
    - public void flush() 刷新此输出流并强制任何缓冲的输出字节被写出
    - public void write(int b) 将指定的字节写入此输出流
    - public void write(byte[] b) 将b.length字节从指定的字节数组写入此输出流
    - public void write(byte[] b，int off,int len)
        - 从指定的字节数组写入len字节,从偏移量off开始输出到此输出流
    - FileOutputStream：文件字节输出流，是OutputStream的子类
        - 作用：把内存中的数据写入硬盘中的文件中
        - 构造方法：
            - FileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流
            - FileOutputStream(File file) 创建一个向具有指定File对象表示的文件中写入数据的输出文件流
        - 使用步骤：
            - 1.创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
            - 2.调用FileOutputStream对象中的write方法，把数据写入文件中
            - 3.释放资源
    - 续写和换行：
        - 续写：使用两个参数的构造方法
            - FileOutputStream(String filename,boolean append)
            - FileOutputStream(File file,boolean append)
            - 参数append为续写开关
                - true：不会创建新文件覆盖原文件可以续写
                - false：创建新的文件会覆盖原文件
        - 换行：换行符号
            - Windows：\r\n
            - Linux:/n
            - mac:/r
* InputStream：字节输入流，该抽象类是表示输入字节流的所有类的超类
* InputStream中定义了一些子类共性的方法：
    - int read() 从输出流中读取数据的下一个字节
    - int read(byte[] b) 从输出流中读取一定数量的字节，并将其存储在缓冲区数组b中
    - void close() 关闭此输入流并释放与该流关联的所有系统资源
    - FileInputStream：文件字节输出流，是InputStream的子类
        - 作用：把硬盘文件中的数据读取到内存中使用
        - 构造方法：
            - FileInputStream(String name) 创建一个向具有指定名称的文件中读取数据的输入文件流
            - FileInputStream(File file) 创建一个向具有指定File对象表示的文件中读取数据的输入文件流
        - 读取数据的原理：Java程序--&gt;JVM--&gt;OS（操作系统）--&gt;OS读取数据的方法--&gt;读取文件
        - 使用步骤：
            - 1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源
            - 2.调用FileInputStream对象中的read方法，读取文件
            - 3.释放资源</code></pre>
<p>字符流</p>
<pre><code>* Reader：字符输入流，是字符输入流的最顶层的父类，是一个抽象类
    - 共性方法：
        - int read() 读取单个字符并返回
        - int read(char[] b) 一次读取多个字符，并将其存储在缓冲区数组b中
        - void close() 关闭此输入流并释放与该流关联的所有系统资源
    - FileReader：文件字符输入流，是Reader的子类
        - 作用：把硬盘文件中的数据以字符的方法读取到内存中
        - 构造方法：
            - FileReader(String filename)
            - FileReader(File file)
* Write：字符输出流，是字符输出流的最顶层的父类，是一个抽象类
    - 共性方法：
        - public void close() 关闭此输出流并释放与此流相关联的任何系统资源，但先要刷新它
        - public void flush() 刷新此输出流并强制任何缓冲的输出字节被写出
        - public void write(int c) 将指定的字符写入此输出流
        - public void write(char[] c) 将指定的字符数组写入此输出流
        - public void write(char[] c，int off,int len)
            - 写入字符数组的某一部分，从数组的off索引开始，写len的字符个数
        - public void write(String str) 写入字符串
        - public void write(String str)
            - 写入字符串的某一部分，从字符串的off索引开始，写len的字符个数
    - close与flush的区别：
        - flush：刷新缓冲区，流对象可以继续使用
        - close：先刷新缓冲区，然后释放系统资源，流对象不可以继续使用
    - FileWrite：文件字符输出流，是Write的子类
        - 作用：把内存中字符数据写入到文件中
        - 构造方法：
            - FileWrite(String filename)
            - FileWrite(File file)
    - 续写和换行：
        - 续写：使用两个参数的构造方法
            - FileWrite(String filename,boolean append)
            - FileWrite(File file,boolean append)
            - 参数append为续写开关
                - true：不会创建新文件覆盖原文件可以续写
                - false：创建新的文件会覆盖原文件
        - 换行：换行符号
            - Windows：\r\n
            - Linux:/n
            - mac:/r
* JDK7的新特性：
    - 在try的后面可以加一个()，在括号中可以定义流对象，那么这个流的作用域就在try中有效，
        try中的代码执行完毕后会自动将流对象释放，不用再写finally
    - 格式：
        try(定义流对象;定义流对象...)&#123;
            可能会出现异常的代码
        &#125;catch(异常类变量 变量名)&#123;
            异常的处理逻辑
        &#125;
* JDK9的新特性：
    - try的前面可以定义流对象，在try后边的()中可以直接引入流对象的名称，
        try中的代码执行完毕后会自动将流对象释放，不用再写finally
    格式：
        A a=new A();
        B b=new B();
        try(a,b)&#123;
            可能会出现异常的代码
        &#125;catch(异常类变量 变量名)&#123;
            异常的处理逻辑
        &#125;</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/12/09/Java/Java27-File%E7%B1%BB/">Java27-File类</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-12-09
        
    </p>

    

    <!-- Content -->
    <p>File</p>
<pre><code>* Java把电脑中的文件和文件夹（目录）封装为一个File类，我们可以使用File类对文件和文件夹
    进行操作，该类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法
* File类中常用的静态方法：
    - static String pathSeparator 返回与系统有关的路径分隔符
        - windows系统为分号（;）
        - linux系统为冒号（:）
    - static char pathSeparator 返回与系统有关的路径分隔符
    - static String separator 返回与系统有关的默认名称分隔符
        - windows系统为反斜杠（\）
        - linux系统为正斜杠（/）
    - static char separator 返回与系统有关的默认名称分隔符
* File类的构造方法：
    - File(File parent,String child) 根据parent抽象路径和child路径名字符串创建一个新的File实例
    - File(String parent,String child) 根据parent路径名字符串和child路径名字符串创建一个新的File实例
    - File(String pathname) 根据指定的路径名字符串创建一个新的File实例
* File类获取功能的方法：
    - public String getabsolutePath() 返回此File的绝对路径名字符串
    - public String getPath() 将此File转换为路径名字符串
    - public String getName() 返回此File表示的文件或目录（文件夹）名称
    - public long Length() 返回此File表示的文件的长度
        - 注意：
            - 获取的是构造方法指定的文件的大小，以字节为单位，若构造方法中给出的路径不存在则返回0
            - 文件夹是没有大小概念的，不能获取文件夹的大小
* File类判断功能的方法：
    - public boolean exists() 判断此File表示的文件或目录（文件夹）是否存在
    - public boolean isDirectory() 判断此File表示的是否为目录（文件夹）
    - public boolean isFile() 判断此File表示的是否为文件
* File类常用的方法：
    - public boolean createNewFile() 当且仅当具有该名称的文件不存在时，创建一个新的空文件
    - public boolean delete() 删除由此File表示的文件或目录（文件夹）
        - 该方法直接在硬盘删除文件/文件夹，不走回收站，因此删除要谨慎
    - public boolean mkdir() 创建由此File表示的目录（文件夹）
    - public boolean mkdirs() 创建由此File表示的多级目录（文件夹）
* File类遍历文件夹功能：
    - public String[] list() 返回一个String数组，表示该File目录中所有的子文件或目录
        - 遍历出来的是相对路径
    - public File[] listFiles() 返回一个String数组，表示该File目录中所有的子文件或目录
        - 遍历出来的是绝对路径
* 过滤器
    - 在File类中有两个和listFiles重载的方法，方法的参数就是过滤器
    - public File[] listFiles(FileFilter filter)
        - FileFilter接口用于抽象路径名（File对象）的过滤器
        - 作用：用来过滤文件（File对象）
        - boolean accept(File pathname) 测试指定抽象路径名是否包含在某个路径名列表中
            - pathname使用listFiles方法遍历得到的每一个文件对象
    - public File[] listFiles(FilenameFilter filter)
        - FileFilter接口用于抽象路径名（File对象）的过滤器
        - 作用：用来过滤文件（File对象）
        - boolean accept(File dir,String name) 测试指定抽象路径名是否包含在某个路径名列表中
            - pathname使用listFiles方法遍历得到的每一个文件对象
    - 注意：两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤的方法accept，
            在方法中自己设置过滤的规则</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/12/09/Java/Java26-Lambda/">Java26-Lambda</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-12-09
        
    </p>

    

    <!-- Content -->
    <p>Lambda</p>
<pre><code>* Lambda 函数式编程思想：只要能获取到结果，谁去做，怎么做的都不重要，重视的是结果，不重视过程
* 使用前提：
    - 使用Lambda必须有接口，且要求接口内有且仅有一个抽象方法
    - 使用Lambda必须有上下文推断
* Lambda表达式的省略：
    - 1.（参数列表）：括号中参数列表的数据类型可以省略不写
    - 2.（参数列表）：括号中的参数若只有一个，那么类型和（）都可以省略
    - 3.&#123;一些代码&#125;：若&#123;&#125;中的代码中有一行，无论是否有返回值都可以省略&#123;&#125;、return、分号
        - 注意：&#123;&#125;、return、分号必须一起省略
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods(10, 20, new demo02() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public int method(int a, int b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	System.out.println(&quot;--------------------&quot;);</span><br><span class="line">	methods(10,20,(int a,int b)-&gt;&#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/12/07/Java/Java25-%E7%BA%BF%E7%A8%8B/">Java25-线程</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-12-07
        
    </p>

    

    <!-- Content -->
    <p>线程</p>
<pre><code>* 进程：指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；
        进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行
            到消亡的过程
* 线程：线程是进程的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，
        一个进程也可以包括多个线程，这个应用程序可以称之为多线程程序
* 并发与并行
    - 并发：指两个或多个事件在同一个时间段内发生
    - 并行：指两个或多个事件在同一时刻发生（同时发生）
* 线程调度
    - 分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间
    - 抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同则会随机选择一个（线程随机性）
        Java使用的便是抢占式调度
* 单线程
    - 单线程程序：Java程序中只有一个线程，执行从main方法开始，从上到下依次执行
    - 主线程：执行主（main）方法的线程，JVM执行main方法，main方法会进入到栈内存中，JVM会
                操作系统开辟一条main方法通向CPU的执行路径，CPU就可以通过这条路径来执行main
                    方法，这条路径就叫主（main）线程
* 多线程
    - 创建多线程程序的第一种方法：创建Thread的子类
        - Thread类是描述线程的类
        - 实现步骤：
            - 1.创建一个Thread的子类
            - 2.在Thread的子类中重写run方法，设置线程任务（开启线程之后要做什么）
            - 3.创建Thread的子类对象
            - 4.调用Thread类中的start()方法，开启新的线程，执行run方法
                - void start() 使线程开始执行；Java虚拟机调用该线程的run方法
                    结果是两个线程并发的运行
        - 注意：多次启动一个线程是非法的，特别是当线程已经结束执行后，不能再重新启动
    - 创建多线程程序的第二种方法：实现Runnable接口
        - 通过Runnable接口创建一些打算通过某一线程执行其实例的实现类，该类必须定义一个名为run的无参方法
        - Thread类的构造方法：
            - Thread(Runnable target) 分配新的Thread对象
            -  Thread(Runnable target,String name) 分配新的Thread对象并为其命名
        - 实现步骤：
            - 1.创建一个Runnable接口的实现类
            - 2.在实现类中重写Runnable接口的run方法，设置线程任务
            - 3.创建一个Runnable接口的实现类对象
            - 4.创建Thread类对象，构造方法中传递传递Runnable接口的实现类对象
            - 5.调用Thread类中的start()方法，开启新的线程执行run方法
        - 实现Runnable接口创建多线程的好处：
            - 1.避免了单继承的局限性：一个类只能继承一个类，类继承了Thread类就不能继承其他的类了
                但实现了Runnable接口还可以继承其他的类，实现其他的接口
            - 2.增强程序的扩展性，降低了程序的耦合性（解耦），因为实现Runnable接口的方式，
                把设置线程任务和开启新的线程进行了分离（解耦）
    - 匿名内部类实现线程的创建
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        Runnable r&#x3D;new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - 获取线程的名称：
        - 使用Thread类中的getName()方法
            - String getName() 返回该线程的名称
        - 可以先通过currentThread()获取到当前正在执行的线程，使用线程中的getName()方法获取线程的名称
            - static Thread currentThread() 返回当前正在执行的线程对象
    - 设置线程的名字：
        - 使用Thread类中的setName()方法
            - String setName(String name) 设置该线程的名称
        - 创建一个带参数的构造方法，参数传递线程的名称；调用父类的带参数构造方法，把线程名称传递给父类
            - Thread(String name) 分配新的Thread对象
    - 暂停线程：
        - public static void sleep(long millis)
            - 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），毫秒数结束之后线程继续执行
    - 同时使用多个共享数据的线程时可能会出现线程安全问题
        - 解决线程安全的第一种方法：使用同步代码块
            - 格式：synchronized(锁对象)&#123;可能出现线程安全问题的代码（访问了共享数据的代码）&#125;
            - 注意：
                - 代码块中的锁对象可使用任意的对象，但必须保证多个线程使用的锁对象是同一个
                - 锁对象作用：当第一个线程进入同步代码块时，将锁对象取走，然后第二个线程来到同步
                            代码块处，锁对象已被取走，因此无法进入同步代码块，只有当第一个线程
                            执行完同步代码块中的内容之后将锁对象归还，第二个线程才能获得锁对象
                            进入同步代码块，即同时只会让一个线程在同步代码块中执行
        - 解决线程安全的第二种方法：使用同步方法
            - 使用步骤：
                - 1.把访问了共享数据的代码抽取出来，放到一个方法中
                - 2.在方法上添加synchronized修饰符
            - 此方法的锁对象就是调用该方法的对象，即this
            - 格式：
                    修饰符 synchronized 返回值类型 方法名(参数列表)
                    &#123;
                        可能出现线程安全问题的代码（访问了共享数据的代码）
                    &#125;
            - 静态同步方法：在同步方法基础上添加static修饰符
                - 在静态同步方法中锁对象不再是this，因为this是创建对象之后产生的，而静态方法优先于对象
                    在静态同步方法中锁对象是本类的class属性--&gt;class文件对象（反射）
        - 解决线程安全的第三种方法：使用Lock锁
            - Lock接口实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作
            - Lock接口中的方法：
                - void lock() 获取锁
                - void unlock() 释放锁
            - Lock接口的实现类ReentrantLock
            - 使用步骤：
                - 1.在成员位置创建一个ReentrantLock对象
                - 2.在可能出现线程安全问题的代码(访问了共享数据的代码前调用)前Lock接口中的lock()方法
                - 2.在可能出现线程安全问题的代码(访问了共享数据的代码前调用)后Lock接口中的unlock()方法
    - 使线程进入Waiting（无限等待）的方式：
        - 使用wait() 线程进入无限等待状态，除非被唤醒，醒来后进入到Runnable/Blocked状态
    - 使线程进入TimeWaiting（计时等待）有两种方式：
        - 1.使用sleep(long m) 线程进入TimeWaiting,在毫秒数结束后，线程睡醒进入到Runnable/Blocked状态
        - 2.使用wait(long m) 在毫秒数结束后还没被notify唤醒就会自动醒来进入到Runnable/Blocked状态
    - 唤醒线程的方法：
        - void notify() 唤醒在此对象监视器上等待的单个线程
        - void notifyAll() 唤醒在此对象监视器上等待的所有线程
* 线程池
    - 线程池其实就是一个容纳多个线程的容器，其中的线程可以反复使用
    - Executors类：线程池的工厂类，用来生成线程池
    - Executors类中的静态方法：
        - static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池
            - 参数：创建线程池中包含的线程数量
    - ExecutorService接口：线程池接口
        - submit(Runnable task) 用来从线程池中获取线程，调用start方法，执行线程方法
        - void shuydown() 关闭/销毁线程池的方法
    - 使用步骤：
        - 1.使用线程池的工厂类Executors类中的静态方法newFixedThreadPool生产一个指定线程数量的线程池
        - 2.创建一个类实现Runnable接口，重写run方法，设置线程任务
        - 3.调用ExecutorService接口中的submit方法，传递线程任务（实现类），开启线程，执行run方法
        - 4.调用ExecutorService接口中的shuydown方法</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/12/06/Java/Java24-%E5%BC%82%E5%B8%B8%E7%B1%BB/">Java24-异常类</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-12-06
        
    </p>

    

    <!-- Content -->
    <p>异常类</p>
<pre><code>* Throwable类时Java语言中所有错误或异常的超类（父类）
    - Exception：编译期异常，进行编译（写代码）Java程序时出现的问题
    - RuntimeException：运行期异常，Java程序运行过程中出现的问题
        - 异常就相当于程序得了一个小毛病，把异常处理掉程序就可以继续运行
    - Error：错误，相当于程序得了一个无法治愈的毛病，必须修改源代码
* 异常产生的过程
    - 1.首先JVM会根据异常产生的原因创建一个异常对象，这个异常对象包括了异常产生的原因、内容、位置，
        出现异常的代码若没有异常的处理逻辑（try...catch），那么JVM就会把异常对象抛出给该代码的调用者，
            调用者依次抛出，直到抛出到main方法那
    - 2.main方法接收到了这个异常对象，若main方法也没有异常的处理逻辑，则继续把异常对象抛出给main方法的
        调用者JVM处理
    - 3.JVM接收到这个异常后，把异常对象的原因、内容、位置以红色字体打印在控制台，随后JVM会终止当前正在
        执行的Java程序--&gt;中断处理
* throw关键字
    - 作用：可以使用throw关键字在指定的方法中抛出指定的异常
    - 使用格式：throw new Exception(&quot;异常产生的原因&quot;);
    - 注意：
        - throw关键字必须写在方法的内部
        - throw关键字后边new的对象必须是Exception或Exception的子类对象
        - throw关键字抛出指定的异常后，我们必须处理这个异常对象
            - throw关键字后面创建的是RuntimeException或者是RuntimeException的子类对象，
                我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）
            - throw关键字后面创建的是编译异常，我们就必须处理这个异常，要么throws，要么try...catch
* Object类中的静态方法
    - public static &lt;T&gt; T requireNonNull(T obj) 查看指定引用对象是不是null
    - public static &lt;T&gt; T requireNonNull(T obj, String message ) 查看指定引用对象是不是null
        - message是若指定引用对象为null是抛出异常的内容
* throws关键字：处理异常的第一种方法，交给别人处理
    - 作用：把异常对象声明抛出给方法的调用者处理，最终交给JVM处理--&gt;中断处理
    - 使用格式：在方法声明处使用
        - 修饰符 返回值类型 方法名(参数列表) throws Exception
    - 注意：
        - throws关键字后边new的对象必须是Exception或Exception的子类对象
        - 方法内部如果抛出了多个异常对象，那么throws关键字后边必须也声明多个异常
            如果抛出的多个异常对象有父子类关系，那么直接声明父类异常即可
        - 调用一个声明抛出异常的方法，我们就必须处理声明的异常，要么继续使用throws声明抛出，
            最终交给JVM处理，要么try...catch自己处理异常
* try...catch：异常的第二种处理方法，自己处理异常
    - 格式：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    可能出现异常的代码</span><br><span class="line">&#125;catch(异常类名 变量名（定义一个异常的变量，用来接收try抛出的异常对象）)&#123;</span><br><span class="line">    异常的处理逻辑，接受异常后怎么处理异常对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - 注意：
        - try中可能会抛出多个异常对象，那么就必须使用多个catch来处理这些异常对象，当catch里边定义的
            异常变量具有父子类关系，那么子类的异常变量必须写在上边，否则就会报错
        - 若try中产生了异常，则会执行catch中的异常处理逻辑，然后继续执行try...catch之后的代码
            若try中没产生了异常，则不会执行catch中的异常处理逻辑，然后继续执行try...catch之后的代码
* Throwable类中定义了三个与异常处理有关的方法
    - String getMessage() 返回此异常的简短描述
    - String toString() 返回此异常的详细信息字符串
    - String printStackTrace() JVM打印异常对象，默认此方法，打印的异常信息最为全面
* finally代码块
    - 格式：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    可能出现异常的代码</span><br><span class="line">&#125;catch(异常类名 变量名（定义一个异常的变量，用来接收try抛出的异常对象）)&#123;</span><br><span class="line">    异常的处理逻辑，接受异常后怎么处理异常对象</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    无论是否出现异常都执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - 注意：
        - finally不能单独使用，必须和try一起使用
        - finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放（IO）
* 父子类的异常
    - 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常
    - 父类方法没有抛出异常，子类重写父类方法时也不可抛出异常，此时子类产生异常，只能捕获处理，不能声明
    - 父类异常是什么样，子类异常就是什么样
* 自定义异常类
    - Java提供的异常类不够我们使用时，就需要自己去定义一些异常类
    - 格式：
        public class XXXException extends Exception/RuntimeException&#123;
            添加一个空参数的构造方法（创建一个无参构造方法，然后在方法里边调用父类构造方法即super()）
            添加一个带异常信息的构造方法（创建一个带参构造方法，在方法里边调用父类构造方法即super()）
        &#125;
    - 注意：
        - 自定义异常类一般都是以Exception结尾，说明该类是一个异常类
        - 自定义异常类继承Exception说明是一个编译期异常，如果方法内部抛出了编译期异常就必须处理
            若继承RuntimeException则是一个运行期异常，无需处理，交给虚拟机处理（中断处理）</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/12/06/Java/Java23-%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88/">Java23-双列集合</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-12-06
        
    </p>

    

    <!-- Content -->
    <p>双列集合</p>
<pre><code>* Map集合
    - 特点：
        - Map集合是一个双列集合，一个元素包括两个值（一个key，一个value）
        - Map集合中的元素，key和value的数据类型可以相同，也可以不同
        - Map集合中的元素，key是不允许重复的，value可以重复
        - Map集合中的元素，key和value是一一对应的
    - 常用的成员方法：
        - public V put(K key,V value) 把指定的键与指定的值添加到Map集合中
            - 存储键值对的时候key不重复则返回值V是null
            - 存储键值对的时候key重复则会使用新的value替换map中重复的value，返回被替换的value值
        - public V remove(Object key) 把指定的键对应的键值对在Map集合中删除，返回被删除元素的值
            - key存在返回被删除的键值对的值
            - key不存在则返回null
        - public V get(Object key) 返回指定的键在Map集合中所对应的值
            - key存在则返回对应的value值
            - key不存在则返回null
        - boolean containsKey(Object key) 判断Map集合中是否包含指定的键
            - 包含则返回true
            - 不包含则返回false
    - Map集合中的遍历方法：
        - 通过键找值的方式：
            - Set&lt;K&gt; keySet() 返回此映射中包含的键的set视图，即返回一个存储了Map集合中所有键的Set集合
            - 实现步骤：
                - 使用Map集合中的方法keySet()，把Map集合中所有的key取出来存储到一个Set集合中
                - 遍历Set集合，获取Map集合中每一个key
                - 使用Map集合中get()方法获取每一个key所对应的value值
        - 使用Entry对象遍历：
            - Map集合中的方法：
                - Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图
            - 实现步骤：
                - 使用Map集合中的方法entrySet()，把Map集合中所有的Entry对象取出来存储到一个Set集合中
                - 遍历Set集合，获取Map集合中每一个Entry对象
                - 使用Entry对象中的方法getKey()和getValue()获取键与值
* HashMap集合
    - 特点：
        - 底层是哈希表：查询速度特别快
            - JDK1.8之前：数组+单向列表
            - JDK1.8之后：数组+单向列表/红黑树（链表的长度超过8）：提高查询的速度
        - HashMap集合是一个无序集合
    - 存储指定类型的键值
        - 由于Map集合保证key是唯一的，因此作为key的元素必须重写hashCode()和equals()方法以保证key唯一
* LinkedHashMap集合
    - 特点：
        - 底层是哈希表+链表（保证迭代的顺序）
        - LinkedHashMap集合是一个有序的集合
* Hashtable集合
    - 特点：
        - 底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢
        - 不可以存储null值，null键
        - Hashtable集合和Vector集合一样，在JDK1.2版本之后被更先进的集合所取代
            但Hashtable的子类Properties依然活跃，Properties集合是一个唯一和IO流相结合的集合
* JDK之后的新特性：
    - List接口、Set接口、Map接口里边增加了一个静态的方法of(),可以给集合一次性添加多个元素
        - 格式（用List集合举例）:static &lt;E&gt; List&lt;E&gt; of(E,elements)
    - 使用前提：当集合中存储的元素的个数已经确定了，不再改变时使用
    - 注意：
        - of方法只适用于List接口、Set接口、Map接口，不适用于接口的实现类
        - 该方法的返回值是一个不可改变的集合，集合不能再使用add,put方法添加元素，否则会抛出异常
        - Set接口、Map接口在调用该方法时，不能有重复的元素，否则会抛出异常</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/12/04/Java/Java22-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/">Java22-可变参数</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-12-04
        
    </p>

    

    <!-- Content -->
    <p>可变参数</p>
<pre><code>* 可变参数是JDK1.5之后出现的新特性
* 使用前提：方法的参数列表数据类型已确认，但参数的个数不确定，就可以使用可变参数
* 使用格式：修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;
* 原理：可变参数底层是一个数组，根据传递参数的个数不同，会创建不同长度的数组来存储这些参数
    传递的参数个数可以是0个（不传递）、1、2....多个
* 注意事项：
    - 一个方法的参数列表只能有一个可变参数
    - 如果方法的参数有多个，那么可变参数必须写在参数列表末尾</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/30/Java/Java21-%E6%B3%9B%E5%9E%8B/">Java21-泛型</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-30
        
    </p>

    

    <!-- Content -->
    <p>泛型</p>
<pre><code>* 泛型是一个未知的数据类型，当我们不确定使用什么类型的数据时，可以使用泛型
* 泛型的好处和弊端：
    - 创建集合对象不使用泛型：
        - 好处：集合不使用泛型，默认的类型是Object类型，可以储存任意类型的数据
        - 弊端：不安全，会引发异常
    - 创建集合对象使用泛型：
        - 好处：避免了类型转换的麻烦，存储的是什么类型取出就是什么类型
        - 弊端：泛型是什么类型就只能储存什么类型的数据
* 定义一个含有泛型的类：
    - 格式：public class 类名&lt;E&gt;&#123;...&#125;
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class myClass&lt;E&gt;&#123;</span><br><span class="line">    private E name；</span><br><span class="line">    public E getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(E name)&#123;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 定义一个含有泛型的的方法：
    - 格式：
        修饰符 &lt;E&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体;&#125;
    - 含有泛型的方法，在调用方法时确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class myMethods&#123;</span><br><span class="line">    &lt;!-- 定义一个含有泛型的普通方法 --&gt;</span><br><span class="line">    public &lt;M&gt; void method01(M m)&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">     &lt;!-- 定义一个含有泛型的静态方法 --&gt;</span><br><span class="line">    public static &lt;E&gt; void method01(E e)&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 含有泛型的接口，第一种使用方式：定义接口的实现类实现接口，指定接口的泛型
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class myImpl implements myInterface&lt;String&gt;&#123;</span><br><span class="line">    public void method(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 含有泛型的接口，第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class myImpl&lt;E&gt; implements myInterface&lt;E&gt;&#123;</span><br><span class="line">    public void method(E e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 泛型的通配符：
    - ? 代表任意的数据类型
    - 使用方式：不能创建对象使用，只能作为方法的参数使用
    - 注意：泛型没有继承概念
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class myClass&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list01&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(1);</span><br><span class="line">        list01.add(2);</span><br><span class="line">        ArrayList&lt;String&gt; list01&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        list01.add(&quot;a&quot;);</span><br><span class="line">        list01.add(&quot;b&quot;);</span><br><span class="line">        &#x2F;&#x2F;若ArrayList&lt;i&gt; list03&#x3D;new ArrayList&lt;i&gt;(); 则会报错</span><br><span class="line">    &#125;</span><br><span class="line">    public static void printArray(ArrayList&lt;?&gt; list)&#123;</span><br><span class="line">        &#x2F;&#x2F;使用迭代器遍历</span><br><span class="line">        Iterator it&#x3D;list.iterator();</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            Object o&#x3D;it.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 泛型的上下限定
    - 泛型的上限限定：? extends E   代表使用的泛型只能是E类型或E类型的子类
    - 泛型的下限限定：? super E   代表使用的泛型只能是E类型或E类型的父类
    - 类与类之间的继承关系：
        - Integer extends Number extends Object
        - String extends Object</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/30/Java/Java20-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E3%80%81Collection%E6%8E%A5%E5%8F%A3%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/">Java20-单列集合、Collection接口与迭代器</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-30
        
    </p>

    

    <!-- Content -->
    <p>Collection</p>
<pre><code>* java.util.Collection接口，所有单列集合最顶层的接口，里面定义了所有单列集合共性的方法
* 单列集合层级：
    - Collection接口(最顶层)
        - List接口：有序的集合，允许存储重复的元素，有索引，可以使用普通的for循环遍历
            - ArrayList类：底层是数组实现的，查询快，增删慢
            - LinkedList类：底层是链表实现的，查询慢，增删快
            - Vector类
        - Set接口：不允许存储重复元素，没有索引
            - HashSet类：无序的集合，底层是哈希表+(红黑树)实现的
                - LinkedHashSet类：有序的集合，底层是哈希表+链表实现的
            - TreeSet类：无序的集合，底层是二叉树实现的，一般用于排序
* 共性的方法：
    - public boolean add(E e);  将指定的对象添加到当前集合中
        - - 添加成功返回true，反之返回false
    - public void clear();  清空集合中所有元素
        - 清空集合中所有元素，但不删除集合，集合本身还在
    - public boolean remove(E e);  将指定的对象在当前集合中删除
        - 删除成功返回true，反之返回false
    - public boolean contains(E e);  判断当前集合是否包括指定对象
        - 包含返回true，反之返回false
    - public boolean isEmpty();  判断当前集合是否为空
        - 为空返回true，反之返回false
    - public int size();  返回当前集合的长度
    - public Object[] toArray();  把集合中的元素存储到数组中</code></pre>
<p>Iterator（迭代器）</p>
<pre><code>* java.util.Iterator接口：迭代器（对集合进行遍历）
* 常用方法：
    - boolean hasNext() 判断集合中还有没有下一个元素，有就返回true，反之返回false
    - E next()  返回集合的下一个元素
* Iterator（迭代器）是一个接口，我们无法直接使用，需要使用Iterator接口的实现类对象，获取实现类
    的方法比较特殊，通过Collection接口中的iterator()方法获取
        Iterator&lt;E&gt; iterator()返回在此collection上进行迭代的迭代器
* 迭代器使用步骤
    - 使用集合中的iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）
    - 使用Iterator接口中的方法hasNext()判断还有没有下一个元素
    - 使用Iterator接口中的方法next()取出集合中的下一个元素
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; str&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it&#x3D;str.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    String s&#x3D;it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
* 增强for循环（forEach）：底层使用的也是迭代器，是JDK1.5之后出现的新特性，用于遍历集合和数组
    - 格式：
        for(集合/数组的数据类型 变量名:集合名/数组名)&#123;
            System.out.println(变量名);
        &#125;
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; str&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">str.add(&quot;aaa&quot;);</span><br><span class="line">str.add(&quot;bbb&quot;);</span><br><span class="line">str.add(&quot;ccc&quot;);</span><br><span class="line">for(String s:str)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>List</p>
<pre><code>* List接口：有序的集合，允许存储重复的元素，有索引，可以使用普通的for循环遍历
* 带索引的成员方法：
    - public void add(int index,E element); 将指定的元素添加至该集合中指定的位置上
    - public E get(int index); 返回集合中指定位置的元素
    - public E remove(int index); 删除集合中指定位置的元素并返回被删除的元素
    - public E set(int index,E element); 用指定元素替换集合中指定位置的元素并返回替换前的元素
    - 注意：操作索引的时候一定要防止索引越界</code></pre>
<p>Set</p>
<pre><code>* Set接口：不允许存储重复元素，没有索引,因此不可以使用普通的for循环遍历集合
* 不允许存储重复元素的原因：
    - Set集合在调用add方法时，add方法会调用元素的hasCode方法和equals方法，判断对象是否重复
        首先调用hasCode方法判断对象的哈希值是否相等，若相等则调用equals方法判断对象的值是否相等</code></pre>
<p>HashSet</p>
<pre><code>* HashSet集合存储数据的结构为哈希表
* 哈希表
    - jdk1.8之前，哈希表=数组+链表；jdk1.8之后，哈希表=数组+红黑树（提高查询的速度）
    - 特点：增删慢，查询快
    - 哈希表将哈希值相等的对象分到一组
* 哈希值
    - 是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑值，一个模拟出来的值，
        不是数据实际存储的物理地址）
    - 在Object类中有一个方法，可以获取对象的哈希值
        - public native int hasCode() 返回该对象的哈希值
            - native代表该方法调用的是本地操作系统的方法
* HashSet存储自定义类型元素时必须重写hasCode方法和equals方法</code></pre>
<p>LinkedHashSet</p>
<pre><code>* LinkedHashSet的特点：有序，底层是一个哈希表（数组+链表/红黑树）+链表，
    多了一条链表（记录元素的存储顺序），保证元素有序</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>




<div id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    主题 <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/main.js"></script>


</body>

</html>
