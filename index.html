<html>

<head>
    <meta charset="utf-8">
    
    <title>小戴的学习日记</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/tagplugins.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="小戴的学习日记" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Dcq66.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">小戴的学习日记</h1>
    <p class="lead blog-description">Dcq66.github.io</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/22/ES6/ES6-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F/">ES6-常量与变量</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-22
        
    </p>

    

    <!-- Content -->
    <p>常量</p>
<pre><code>* 格式：const 常量名称=&quot;常量值&quot;;
* 注意事项：
    - 一定要赋初始值
    - 一般常量都用大写字母命名（推荐）
    - 常量的值不能修改
    - 块级作用域：只在当前大括号以及大括号所包含的下级大括号中起作用
    - 对于赋予常量的数组和对象中的元素修改时，不算做对常量的修改</code></pre>
<p>变量</p>
<pre><code>* 格式：let 变量名称=&quot;变量值&quot;;
* 注意事项：
    - 块级作用域：只在当前大括号以及大括号所包含的下级大括号中起作用
    - 不存在变量提前</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/22/Java/Java13-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/">Java13-抽象类与接口</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-22
        
    </p>

    

    <!-- Content -->
    <p>抽象类</p>
<pre><code>* 抽象方法：就是普通方法加上abstract关键字，然后去掉大括号，直接分号结束
* 抽象类：抽象方法所在的类必须抽象类，但抽象类中的方法不一定要必须是抽象方法，在class之前加上abstract
* 如何使用抽象方法和抽象类：
    - 不能直接创建new抽象类对象
    - 必须创建一个子类来继承抽象类才能使用
    - 子类必须覆盖重写抽象父类当中所有的抽象方法
        - 覆盖重写实现：子类去掉父类中的抽象方法的abstract关键字，然后补上方法体大括号</code></pre>
<p>接口</p>
<pre><code>* 接口就是多个类的公共规范，是一种引用数据类型
* 格式：public interface 接口名称&#123;&#125;
* 换成关键字interface之后，编译生成的字节码文件仍是：.java --&gt; .class
* 接口使用：
    - 接口不能直接使用，必须有一个实现类来实现接口
    - 格式：public class 实现类名称 implements 接口名称&#123;&#125;
    - 实现类必须覆盖重写接口中的所有抽象方法
        - 覆盖重写实现：实现类去掉接口中的抽象方法的abstract关键字，然后补上方法体大括号
    - 创建实现类的对象进行使用
    - 注意事项：
        - 如果实现类没有重写接口中所有的抽象方法，那这个实现类自己就必须是抽象类
* 在任意版本的Java中接口都可以定义抽象方法
    - 格式：public abstract 返回值类型 方法名称（参数列表）;
    - 注意事项：
        - 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
        - 这两个关键字可以都省略也可以省略其中一个
* 如果Java7，那么接口中可以包含：
    - 常量
        - 必须使用public static final三个关键字修饰
        - 格式：public static final 数据类型 常量名字=数据值
        - 注意事项：
            - 接口中的常量可以省略public static final，但省略效果也是一样
            - 接口中的常量必须进行赋值
            - 接口中的常量名称使用完全大写的字母，用下划线进行分隔（推进的命名规则）
* 如果Java8，那么接口中可以包含：
    - 默认方法
        - 接口的默认方法，可以通过接口实现类对象直接调用
        - 接口的默认方法也可以被接口实现类覆盖重写
        - 格式：public default 返回值类型 方法名称（参数列表）&#123;&#125;
        - 默认方法可用于解决接口升级的问题
    - 静态方法
        - 格式：public static 返回值类型 方法名称（参数列表）&#123;&#125;
        - 直接通过接口名称调用其中的静态方法
        - 注意事项：
            - 不能通过接口实现类的对象调用接口中的静态方法
* 如果Java9，那么接口中可以包含：
    - 私有方法
        - 普通私有方法
            - 用于解决多个默认方法之间重复代码的问题
            - 格式：private 返回值类型 方法名称（参数列表）&#123;&#125;
        - 静态私有方法
            - 用于解决多个静态方法之间重复代码的问题
            - 格式：private static 返回值类型 方法名称（参数列表）&#123;&#125;
* 使用接口时需注意：
    - 接口没有静态代码块或构造方法的
    - 一个类的父类是唯一的，但一个类可以同时有多个接口，接口之间用逗号分隔开
    - 如果实现类所实现的多个接口中存在重复的抽象方法，那么只要重写一次即可
    - 如果实现类所实现的多个接口中存在重复的默认方法，那么实现类一定要重写重复的默认方法
    - 一个类的父类中的方法和接口中的默认方法重复时，父类方法优先级更高
    - 接口与接口之间也是多继承的</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/19/Java/Java12-this%E4%B8%8Esuper%E5%85%B3%E9%94%AE%E5%AD%97/">Java12-This与super关键字</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-19
        
    </p>

    

    <!-- Content -->
    <p>this</p>
<pre><code>* 当方法的局部变量和类的成员变量重名时，根据“就近原则”，优先使用局部变量
    若需要在方法中访问成员变量可以使用this.成员变量名
* 通过谁调用的方法，this就是谁
* 用this关键字访问本类内容：
    - 在本类的成员方法中，访问本类的成员变量
    - 在本类的成员方法中，访问本类的另一个成员变量
    - 在本类的构造方法中，访问本类的另一个构造变量
    - 注意：
        - this必须是构造方法的第一个语句，唯一一个
        - super和this两种构造调用不能同时调用</code></pre>
<p>super</p>
<pre><code>* super关键字用来访问父类内容：
    - 在子类的成员方法中，访问父类的成员变量
    - 在子类的成员方法中，访问父类的成员方法
    - 在子类的构造方法中，访问父类的构造方法</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/18/Java/Java11-%E7%BB%A7%E6%89%BF/">Java11-继承</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-18
        
    </p>

    

    <!-- Content -->
    <p>继承</p>
<pre><code>* 继承的特点：
    - 子类可以拥有父类的“内容”
    - 子类还可以拥有自己的“专属内容
* 定义父类（基类、超类）的格式（一个普通类的定义）：public class 父类名称&#123;&#125;;
* 定义子类：public class 子类名称 extends 父类名称&#123;&#125;;
* 在父子类的继承关系中，若成员变量/成员方法重名，则创建子类对象时，访问有两种方式：
    - 直接通过子类对象访问成员变量/成员方法：通过谁调用就优先用谁，没有则向上找
    - 间接通过成员方法访问成员变量：该方法属于谁就优先用谁，没有则向上找
    - 注意：无论是成员变量还是成员方法，如果没有都是向上找父类，绝不会向下找子类
* 使用变量：
    - 局部变量：直接写成员变量名
    - 本类的成员变量：this.成员变量名
    - 父类的成员变量：super.成员变量名
* 重写（Override）
    - 概念：在继承关系中方法的名称一样，参数列表也一样
    - 特点：创建的是子类对象则优先使用子类方法
    - 注意事项：
        - 必须保证父子类之间方法的名称、参数列表一样
        - @Override关键字写在方法的前面，可以检测重写是否有效
        - 子类方法的返回值必须小于等于父类方法的返回值范围
        - 子类方法的权限必须大于等于父类方法的权限修饰符
            - public&gt;protected&gt;（default）&gt;private
            - （default）不是关键字，而是什么都不写，留空
* 父子类构造方法的访问特点：
    - 子类构造方法中有一个隐含默认的&quot;super()&quot;调用，所以一定先调用父类构造方法，后执行子类的构造方法
    - 子类构造可以通过super关键字来调用父类重载构造
    - super的父类构造调用必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/18/Java/Java10-static/">Java10-Static</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-18
        
    </p>

    

    <!-- Content -->
    <p>static</p>
<pre><code>* static 静态关键词
* 一旦使用static修饰成员变量/成员方法，那么就成为了静态变量/静态方法，则不属于对象，而是属于类的
    - 如果没有static关键词，那么必须先创建对象，然后通过对象来使用
    - 如果有了static关键词，那么不需要创建对象，可以直接通过类名来使用
    - 无论是成员变量还是成员方法，如果有了static都推荐通过类名称来使用
        - 静态变量：类名称.静态变量
        - 静态方法：类名称.静态方法()
* 注意事项：
    - 静态不能直接访问非静态，因为内存中先有的静态内容，后有的非静态内容
    - 静态方法中不能用this，因为this代表当前对象，通过谁调用的方法，谁就是当前对象
    - 根据类名称访问静态成员变量/成员方法的时候，全程和对象没有关系，只和类有关系
* 静态代码块：static&#123;&#125;;
    - 当第一次用到本类时，静态代码块执行唯一的一次，静态内容总是优先于非静态，
        所以静态代码块比构造方法先执行
    - 用来一次性的对静态成员变量进行赋值</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/17/Java/Java09-%E5%B7%A5%E5%85%B7%E7%B1%BB/">Java09-工具类</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-17
        
    </p>

    

    <!-- Content -->
    <p>Scanner</p>
<pre><code>* Scanner类可以实现键盘输入数据到程序中
    - 获取键盘输入的一个int数字:
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">int num&#x3D;sc.nextInt();</span><br></pre></td></tr></table></figure>
    - 获取键盘输入的一个String字符串:
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">String str&#x3D;sc.next();</span><br></pre></td></tr></table></figure></code></pre>
<p>Random</p>
<pre><code>* Random类用来生成随机数字
    - 方法：
        - nextInt() 获取一个随机的int数字，范围是int所有范围，有正负
        - nextInt(int 参数) 获取一个随机的int数字，范围是0-参数，左闭右开区间</code></pre>
<p>ArrayList</p>
<pre><code>* 数组的长度不可以发生改变，但ArrayList集合的长度可以随意改变
* 格式：ArrayList&lt;泛型&gt; 集合名称=new ArrayList&lt;&gt;();
* 对于ArrayList集合来说，有一个尖括号&lt;E&gt;代表泛型
    从JDK1.7+开始，右侧的尖括号内部可以不写内容，但是&lt;&gt;本身还是得写
        - 泛型：装在集合中的所有元素，全都是统一的类型
        - 注意：泛型只能是引用类型，不能是基本类型
* 注意事项：对于ArrayList集合来说，直接打印得到的不是地址值，而是内容
            若内容是空，得到的是空的中括号[]
* 方法：
    - public boolean add(E e) 向集合中添加元素，参数的类型和泛型一致，返回值为Boolean
        - 注意：对于ArrayList集合添加时一定成功的，但对于其他集合就不一定了
    - public E get(int index) 从集合中获取元素，参数是索引编号，返回值是对应位置的元素
    - public E remove(int index) 从集合中删除元素，参数是索引编号，返回值是被删除的元素
    - public int size() 获取集合的长度，返回值是集合的长度
* 如果希望向ArrayList集合当中储存基本数据类型数据，必须使用基本类型对应的“包装类”
    基本类型        包装类（引用类型，包装类都位于java.lang包下）
    byte            Byte
    short           Short
    int             Integer
    long            Long
    float           Float
    double          Double
    char            Character
    boolean         Boolean
    - 从JDK1.5开始，支持自动装箱、自动拆箱
        - 自动装箱：基本类型--&gt;包装类型
        - 自动拆箱：包装类型--&gt;基本类型</code></pre>
<p>String</p>
<pre><code>* java.lang.String类代表字符串
* 字符串的特点：
    - 字符串的内容永不可变
    - 正因为字符串的内容永不可变，所以字符串是共享的
    - 字符串效果上相当于char[]字符数组，但底层原理是byte[]字节数组
* 创建字符串的方法：
    - 构造方法：
        - public String() 创建一个空白字符串，不含有任何内容
        - public String(char[] array) 根据字符数组的内容来创建对应的字符串
        - public String(byte[] array) 根据字节数组的内容来创建对应的字符串
    - 直接创建：
        - String 字符串名称=&quot;字符串内容&quot;
        - 对于引用类型来说，==进行的是地址值的比较
        - 双引号直接创建的字符串在字符串常量池中，new的不在池中
* 方法
    - public boolean equals(Object obj) 参数可以是任意对象，
        只有参数是一个字符串并且内容相同才会返回true，否则返回false
            - 注意事项：
                - 该方法具有对称性，a.equals(b)和b.equals(a)效果一样
                - 若比较双方一个常量一个变量，推荐把常量字符串写在前面
    - public boolean equalsIgnoreCase() 忽略大小写进行比较
    - public int length() 获得字符串长度
    - public String concat(String str) 将当前字符串和参数字符串拼接成一个新的字符串并返回
    - public char charAt(int index) 获得指定索引位置的单个字符
    - public int indexOf(String str) 查找参数字符串在本字符串首次出现的索引位置，若没有则返回-1
    - public String substring(int index) 截取从参数索引位置一直到字符串末尾的字符串并返回
    - public String substring(int begin,int end) 截取从begin开始，到end结束中间的字符串并返回
        - [begin,end)，左闭右开
    - public char[] toCharArray() 将当前字符串拆分为字符数组作为返回值
    - public byte[] getBytes() 将当前字符串拆分为字节数组作为返回值
    - public String replace(CharSequence oldString,CharSequence newString)
        - 将所有出现的老字符串替换为新的字符串并返回替换之后的新字符串
     -public String[] split(String regex) 按照参数的规则将字符串切分为若干部分
        - 注意事项：
            - split方法的参数是一个“正则表达式“
            - 若按照英文句点切分，必须写&quot;\\.&quot;</code></pre>
<p>Arrays</p>
<pre><code>* Arrays是一个与数组相关的工具类
* 方法：
    - public static String toString(数组) 将参数数组变成字符串
    - public static void sort(数组) 按照默认升序对数组的元素进行排序
        - 若是数值，sort默认按照升序从小到大
        - 若是字符串，sort默认按照字母从小到大
        - 若是自定义的类型，那么这个自定义的类型需要有Comparable或者Comparator接口的支持</code></pre>
<p>Math</p>
<pre><code>* Math类是一个与数学相关的工具类
* 方法：
    - public static double abs(double num) 获取绝对值
    - public static double ceil(double num) 向上取整
    - public static double floor(double num) 向下取整
    - public static long round(double num) 四舍五入
    - Math.PI代表圆周率常量</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/17/Java/Java08-%E5%B0%81%E8%A3%85/">Java08-封装</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-17
        
    </p>

    

    <!-- Content -->
    <p>封装</p>
<pre><code>* 封装就是将一些细节信息隐藏起来，对于外界不可见
* 封装性在Java中的体现：
    - 方法就是一种封装
    - 关键字private也是一种封装
        - 一旦使用关键字private对成员变量进行修饰，那么本类当中仍然可以随意访问
            但超出本类范围之外就不能再直接访问了
        - 因此我们可以采取间接访问private成员变量的方法，就是定义一对Getter/Setter方法</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/16/Java/Java07-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">Java07—类和对象</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-16
        
    </p>

    

    <!-- Content -->
    <p>类和对象</p>
<pre><code>* 类：是一组相关属性和行为的集合，可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物
    - 属性：该事物的状态信息
    - 行为：该事物能够做什么
* 对象：是一类事物的具体体现，对象是类的一个实例，必然具备该类事物的属性和行为
* 类与对象的关系：
    - 类是对一类事物的描述，是抽象的
    - 对象是一类事物的实例，是具体的
    - 类是对象的模板，对象是类的实体
* 定义一个类由两个部分组成：属性和行为
    - 成员变量（属性）
    - 成员方法（行为）
    - 注意事项：
        - 成员变量是直接定义在类当中的，在方法外边
        - 成员方法不用写static关键字
* 通常情况下，一个类并不能直接使用，需要根据类创建一个对象才能使用
    - 导包
        - 引入需要使用的类
        - 格式：import 包名称.类名称
        - 需要引入的类和当前类属于同一个包时，就不需要导包
    - 创建格式：类名称 对象名=new 类名称()
    - 使用：
        - 使用成员变量：对象名.成员变量名
        - 使用成员方法：对象名.成员方法名(),有参则在括号中加入参数
        - 注意：若成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样
* 局部变量和成员变量
    - 定义的位置不一样：
        - 局部变量：在方法的内部
        - 成员变量：在方法的外部，直接写在类中
    - 作用范围不一样：
        - 局部变量：只能在方法中使用
        - 成员变量：整个类全部都可以通用
    - 默认值不一样：
        - 局部变量：没有默认值，如果想要使用必须手动进行赋值
        - 成员变量：有默认值，规则和数组一样
    - 内存的位置不一样：
        - 局部变量：栈内存
        - 成员变量：堆内存
    - 生命周期不一样
        - 局部变量：随着方法进栈而诞生，随着方法出栈消失
        - 成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失
* 匿名对象：只有右边的对象，没有左边的名字和赋值运算符，即new 类名称();
    - 注意事项：匿名对象创建之后只能使用一次
    - 使用建议：如果确定有一个对象只需要使用唯一的一次，就可以使用匿名对象</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/15/Java/Java06-%E5%86%85%E5%AD%98/">Java06——内存</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-15
        
    </p>

    

    <!-- Content -->
    <p>内存</p>
<pre><code>* Java内存需要划分为5个部分：
    - 栈（Stack）：存放的都是方法中的局部变量。方法的运行一定在栈当中运行
        - 局部变量：方法的参数，或是方法内部的变量
        - 作用域：一旦超出作用域立刻从栈内存中消失
    - 堆（Heap）：凡是new出来的东西都在堆内存中
        - 堆内存里面的东西都有一个地址值（16进制）
        - 堆内存中的数据都有一个默认值：
            - 整数类型则默认为0
            - 浮点类型则默认为0.0
            - 字符类型则默认为&#39;\u0000&#39;
            - 如果是布尔类型则默认为false
            - 如果是引用类型则默认为null
    - 方法区（Method Area）：储存.class相关信息，包含方法的信息
    - 本地方法栈（Native Method Stack）：与操作系统有关
    - 寄存器（pc Register）：与CPU有关</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/15/Java/Java04-%E6%96%B9%E6%B3%95/">Java05——方法</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-15
        
    </p>

    

    <!-- Content -->
    <p>方法</p>
<pre><code>* 定义方法的完整格式：
    修饰符 返回值类型 方法名称(参数类型 参数名称, ....)&#123;
        方法体
        return 返回值
    &#125;
    - 修饰符：初学阶段的固定写法为public static
    - 返回值类型：方法最终产生的数据结果是什么类型
    - 方法名称：方法的名字，一般都是小驼峰写法
    - 参数类型：传入方法中的数据类型
    - 参数名字（形参）：进入方法的数据对应的变量名称
    -方法体：方法所执行的代码
    - return：
        - 停止当前方法
        - 将后面的返回值还给调用处
        - 注意：return后面的返回值类型必须和方法名称前面的返回值类型一致
    - 返回值：方法执行后最终产生的数据结果
* 有参数：小括号中有内容，当一个方法需要一些数据条件才能完成任务时，就是有参
* 无参数：小括号中没有内容，当一个方法不需要任何数据条件就能完成任务时，就是无参
* 使用方法的注意事项：
    - 方法应该定义在类当中，不能在方法中定义方法，即方法不能嵌套
    - 多个方法定义的前后顺序无所谓
    - 方法定义之后不会立即执行，只有当调用该方法时才会执行
    - 如果方法有返回值，那么必须写上“return 返回值;”
    - 对于一个没有设置返回值（即void）的方法，可以不写return，若写上return就不能加上返回值，
        即只能return自身
    - 一个方法当中可以有多个return语句，但是必须保证同时只有一个会被执行，两个return不能连写
* 方法的重载（Overload）：多个方法的名称一样，但是参数列表不一样
    - 好处：只需要使用一个方法即可实现多个类似的功能
    - 方法重载只与以下因素有关：
        - 参数个数
        - 参数类型
        - 参数的多类型顺序不同
    - 方法重载与以下因素无关：
        - 参数名称
        - 返回值类型....
* 构造方法
    - 专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法
    - 格式：public 类名称（参数类型 参数名称）&#123;方法体&#125;
    - 注意事项：
        - 构造方法的名称必须和所在类的名称完全一致
        - 构造方法不用写返回值类型，连void都不用写
        - 构造方法不能return一个具体的返回值
        - 如果没有编写构造方法，那么编译器会默认赠送一个构造方法，没有参数、方法体，什么事都不做
        - 一旦编写了至少一个构造方法，那么编译器将不在赠送
        - 构造方法也可以重载</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>




<div id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    主题 <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/main.js"></script>


</body>

</html>
