<html>

<head>
    <meta charset="utf-8">
    
    <title>小戴的学习日记</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon/favicon.ico">
    
<link rel="stylesheet" href="/css/main.css">

    
<link rel="stylesheet" href="/css/tagplugins.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    


    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="小戴的学习日记" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div class="blog-header">
   <a id="menu-nav-icon"><img src="/image/menu.png"/></a>
   <div class="nav-container">
     <nav id="main-nav">
       
         <a class="main-nav-link" href="/">Home</a>
       
         <a class="main-nav-link" href="/archives">Archives</a>
       
     </nav>
   </div>
   <!--
   <div id="search-form-wrap">
     <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Dcq66.github.io"></form>
   </div>
 -->
    <h1 class="blog-title">小戴的学习日记</h1>
    <p class="lead blog-description">Dcq66.github.io</p>
</div>

  <div id='main-part'>
      
    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/08/JavaScript/tools/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-08
        
    </p>

    

    <!-- Content -->
    <p>title: tools<br>自定义的函数</p>
<pre><code>* 定义一个函数用来判断一个元素中是否有指定的class属性值
    有则返回 true 反之返回 false
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">参数：</span><br><span class="line">    obj 要添加 class 属性的元素</span><br><span class="line">    cn 要添加的 class 属性值 </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">function hasClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 创建一个正则表达式</span><br><span class="line">var reg&#x3D;new RegExp(&quot;\\b&quot;+cn+&quot;\\b&quot;);</span><br><span class="line">return reg.test(obj.className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来向一个元素中添加指定的 class 属性值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">参数：</span><br><span class="line">    obj 要添加 class 属性的元素</span><br><span class="line">    cn 要添加的 class 属性值 </span><br><span class="line">--&gt;</span><br><span class="line">function addClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 检查 obj 中是否含有 cn</span><br><span class="line">if(!hasClass(obj,cn))&#123;</span><br><span class="line">obj.className+&#x3D;&quot;&quot;+cn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来删除一个元素中指定的 class 属性值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--         </span><br><span class="line">参数：</span><br><span class="line">obj 要添加 class 属性的元素</span><br><span class="line">cn 要添加的 class 属性值</span><br><span class="line">--&gt;</span><br><span class="line">function removeClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 创建一个正则表达式</span><br><span class="line">var reg&#x3D;new RegExp(&quot;\\b&quot;+cn+&quot;\\b&quot;);</span><br><span class="line">&#x2F;&#x2F; 删除 class</span><br><span class="line">obj.className&#x3D;obj.className.replace(reg,&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

* 定义一个函数用来切换一个类,如果元素中有该类则删除,如果元素中没有该类则添加
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--     </span><br><span class="line">参数：</span><br><span class="line">obj 要添加 class 属性的元素</span><br><span class="line">cn 要添加的 class 属性值</span><br><span class="line"> --&gt;</span><br><span class="line">function toggleClass(obj,cn)&#123;</span><br><span class="line">&#x2F;&#x2F; 检查 obj 中是否含有 cn</span><br><span class="line">if(hasClass(obj,cn))&#123;</span><br><span class="line">&#x2F;&#x2F; 有则删除</span><br><span class="line">removeClass(obj,cn);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&#x2F;&#x2F; 没有则添加</span><br><span class="line">addClass(obj,cn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/05/JavaScript/JavaScript11/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-05
        
    </p>

    

    <!-- Content -->
    <p>计时器</p>
<pre><code>* setInterval()
    - 定时调用
    - 可以将一个函数每隔一段时间执行一次
    - 参数：
        1.回调函数，该函数每隔一段时间被调用一次
        2.每次调用间隔的时间，单位是毫秒
    - 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识
* setTimeout()
    - 延时调用
    - 延时调用一个函数不会马上执行，而是隔一段时间后再执行，而且只会执行一次
    - 参数：
        1.回调函数
        2.执行之前间隔的时间，单位是毫秒
    - 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识
* clearInterval()
    - 可以用来关闭一个定时器
    - 可以接收任意参数，当一个定时器的标识作为参数，这样将关闭标识对应的定时器
        若参数不是一个有效的标识则什么都不做</code></pre>
<p>JSON<br>    * JavaScript Object Notation JS对象表示法<br>    * JS中的对象只有JS自己认识，其他语言都不认识<br>    * JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言识别<br>        并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互<br>    * JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须要加双引号<br>    * JSON中允许的值：<br>        - 字符串<br>        - 数值<br>        - 布尔值<br>        - null<br>        - 对象<br>        - 数组<br>    * 将JSON字符串转换为JS中的对象<br>        - 在JS中为我们提供了一个工具类就叫JSON，这个对象可以帮助我们将一个JSON转换为JS对象<br>            也可以将JS对象转换为JSON<br>        - JSON–&gt;JS<br>            - JSON.parse()<br>                - 将一个JSON转换为JS对象<br>                - 需要一个JSON字符串作为参数，会将该字符串转换为JS对象并将其作为返回值返回<br>        - JS–&gt;JSON<br>            - JSON.stringify()<br>                - 将一个JS转换为JSON对象<br>                - 需要一个JS对象作为参数，会将该对象转换为JSON字符串并将其作为返回值返回<br>        - JSON这个对象在IE7及以下的浏览器中不支持，如果需要兼容IE7及以下的浏览器的JSON操作<br>            可以通过引入一个外部的JS文件来处理</p>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/11/04/JavaScript/JavaScript10/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-11-04
        
    </p>

    

    <!-- Content -->
    <p>方法、属性与事件</p>
<pre><code>* setCapture() 设置该元素对事件进行捕获
* releaseCapture() 取消对事件的捕获
* wheelDelta属性 可以获取鼠标滚轮滚动的方向
    - 向上滚 120 向下滚 -120
    - 用正负来判断滚动方向
    - 火狐中不支持
* detail属性() 可以获取鼠标滚轮滚动的方向，火狐支持
* 键盘事件
    - 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document
    - onkeydown 按键被按下
        - 若一直按着绑定该事件的按键则事件会一直触发
        - 该事件连续触发时，第一次和第二次之间会间隔稍微长一些，其它的会非常的快，这种设计是为了防止误操作
    - onkeyup 按键被松开
    - keyCode 获取按键的编码，通过它可以判断哪个按键被按下
        - 37 左
        - 38 上
        - 39 右
        - 40 下
    - altkey ctrlkey shiftkey
        - 判断alt ctrl shift是否被按下，按下则返回true 反之返回false</code></pre>
<p>BOM</p>
<pre><code>* 浏览器对象模型
* BOM可以使我们通过JS来操作浏览器
* 在BOM中提供了一组对象用来完成对浏览器的操作
* BOM对象
    - Window
        - 代表整个浏览器的窗口，同时window也是网页中的全局对象
    - Navigator
        - 代表当前浏览器的信息，可用来识别不同的浏览器
        - 由于历史原因，Navigator对象中的大部分属性已经不能帮助我们识别浏览器了
        - 一般我们会使用userAgent来判断浏览器的信息，userAgent是一个字符串，
            这个字符串包含有用来描述浏览器信息的内容，不同的浏览器有不同的userAgent
                但在IE11中已经将微软和IE有关的标识都去除了，所以基本不能通过userAgent来识别是否为IE11了
        - 我们可以通过ActiveXObject来判断一个浏览器是否为IE11
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var ua&#x3D;navigator.userAgent;</span><br><span class="line">&lt;!-- 通过正则表达式来检查 --&gt;</span><br><span class="line">if(&#x2F;firefox&#x2F;i.test(ua))&#123;</span><br><span class="line">    alert(&quot;火狐浏览器&quot;);</span><br><span class="line">&#125;else if(&#x2F;chrome&#x2F;i.test(ua))&#123;</span><br><span class="line">    alert(&quot;Chrome浏览器&quot;);</span><br><span class="line">&#125;else if(&#x2F;msie&#x2F;i.test(ua))&#123;</span><br><span class="line">    alert(&quot;IE浏览器&quot;);</span><br><span class="line">&#125;else if(&quot;ActiveXObject&quot; in window)&#123;</span><br><span class="line">    alert(&quot;IE11&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - Location
        - 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息或者操作浏览器跳转页面
        - 若直接输出location则可以获取到当前浏览器地址栏的信息（当前浏览器的完整路径）
            若直接将location属性修改为其他路径则页面会自动跳转到该路径，并且会生相应的历史记录
        - assign() 跳转到其他的页面，作用和直接修改location属性一样
        - reload() 重新加载当前页面，作用和刷新按钮一样
            - 若在方法中传递一个true作为参数，则会强制清空缓存刷新页面
        - replace() 使用一个新的页面替换当前页面，调用完毕后也会跳转页面，
            不会生成历史记录，也不能使用回退按钮回退
    - History
        - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
            但由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
                而且该操作只在当次访问时有效
        - length属性 可以获取到当前访问的链接数量
        - back() 回退到上一个页面，作用和浏览器的回退按钮一样
        - forward() 跳转到下一个页面，作用和浏览器的前进按钮一样
        - go()
            - 跳转到指定的页面
            - 需要一个整数作为参数：
                1：表示向前跳转一个页面，相当于forward()
                2：表示向前跳转两个页面
                -1：表示向后回退一个页面
                -2：表示向后回退两个页面
    - Screen
        - 代表用户的屏幕信息，通过该对象可以获取到用户显示器的相关信息
    - 这些BOM对象在浏览器中都是作为window对象的属性保存的，
        可以通过window对象来使用，也可以直接使用</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/29/JavaScript/JavaScript09/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-29
        
    </p>

    

    <!-- Content -->
    <p>方法、属性与事件</p>
<pre><code>- 修改元素的样式，语法：元素.style.样式名=样式值
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box1.style.width&#x3D;&quot;100px&quot;;</span><br></pre></td></tr></table></figure>
    - 注意：如果CSS样式名中含有-，这样名称在JS中是不合法的，比如：background-color
            需要将这种样式修改为驼峰命名法：
                去掉-，然后将-后的字母大写
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box1.style.backgroundColor&#x3D;&quot;100px&quot;;</span><br></pre></td></tr></table></figure>
- 通过style属性设置的样式都是内联样式，而内联样式拥有较高的优先级
    所以通过JS修改的样式往往会立即显示，但如果在CSS样式中写了!important，
        则此时会导致JS修改样式失效
- 读取样式 语法：元素.style.样式名
    通过style属性设置和读取的都是内联样式，无法读取到CSS样式表中的样式
- 获取元素当前正在显示的样式 语法：元素.currentStyle.样式名
    如果当前元素没有设置样式，则获取它的默认值，currentStyle只有IE浏览器支持
- 在其他浏览器中获取元素当前正在显示的样式可以使用getComputedStyle()这个方法
    该方法是window的方法，可以直接使用
    - 参数：
        - 第一个参数，要获取样式的元素
        - 第二个参数，可以传递一个伪元素，一般都传null
    - 该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过对象.样式来读取样式
        如果获取的样式没有设置则获取到真实值，而不是默认值，
            如没有设置width，它不会获取到auto，而是一个实际长度，但该方法不支持IE8及以下的浏览器
             <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj&#x3D;getComputedStyle(box1,null);</span><br><span class="line">alert(obj.width);</span><br></pre></td></tr></table></figure>
- 所以我们可以自己定义一个函数方法来兼容不同浏览器获取元素样式的方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">参数：</span><br><span class="line">    obj 要获取样式的元素</span><br><span class="line">    name 要获取的样式名</span><br><span class="line"> --&gt;</span><br><span class="line"> function getStyle(obj,name)&#123;</span><br><span class="line">    if(window,getComputedStyle)&#123;</span><br><span class="line">        &lt;!-- 正常浏览器的方法，具有getComputedStyle()方法 --&gt;</span><br><span class="line">        return getComputedStyle(obj,null)[name];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &lt;!-- IE8的方式，没有getComputedStyle()方法 --&gt;</span><br><span class="line">        return obj.currentStyle[name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
- clientWidth clientHeight
    - 这两个属性可以获取元素的可见高度和宽度
    - 这些属性都是不带px的，返回的都是一个数字，可以直接进行计算
    - 会获取元素宽度和高度，包括内容区和内边距
    - 这些属性都是只读不能修改的
- offsetWidth offsetHeight
    - 获取元素整个的高度和宽度，包括内容区、内边距和边框
- offsetParent
    - 获取离当前元素最近的开启了定位的祖先元素，如果都没有开启定位则返回body
- offsetLeft 当前元素相对于其定位父元素的水平偏移量
- offsetTop 当前元素相对于其定位父元素的垂直偏移量
- scrollWidth 获取水平滚动条的长度
- scrollHeight 获取垂直滚动条的长度
- scrollLeft 获取水平滚动条滚动的距离
    - 当满足scrollWidth-scrollLeft=clientWidth时，说明水平滚动条到底了
- scrollTop 获取垂直滚动条滚动的距离
    - 当满足scrollHeight-scrollTop=clientHeight时，说明垂直滚动条到底了
- onmousemove
    - 该事件将会在鼠标在元素中移动时触发
- 事件对象
    - 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数
        该事件对象中封装了当前事件相关的一切信息，如：鼠标的坐标、键盘哪个按键被按下等等...
            在IE8中响应函数被触发时浏览器不会传递事件对象，在IE8及以下的浏览器中，
                是将事件对象作为window对象的属性保存的
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.onmousenove&#x3D;function(event)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- event 事件对象的形参 --&gt;</span><br></pre></td></tr></table></figure>
- clientX clientY
    - 可以获取鼠标指针的水平坐标和垂直坐标
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div.onmousenove&#x3D;function(event)&#123;</span><br><span class="line">    var x&#x3D;event.clientX;</span><br><span class="line">    var y&#x3D;event.clientY;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- event 事件对象的形参 --&gt;</span><br></pre></td></tr></table></figure>
- 事件的冒泡
    - 所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发
    - 取消冒泡：将事件对象的cancelBubble设置为true
- 事件的委派
    - 指将事件统一绑定给元素共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素
        从而通过祖先元素的响应函数来处理事件
- target
    - event中的target可以返回触发事件的对象
- 使用对象.事件=函数的形式绑定响应函数只能同时为一个元素的一个事件绑定一个响应函数
    如果绑定多个则后边的会覆盖掉前边的
- addEventListener()
    - 该方法可以为元素绑定响应函数
    - 参数：
        - 事件的字符串，不要on
        - 回调函数，当事件触发时该函数会被调用
        - 是否在捕获阶段触发事件，需要一个布尔值，一般都传false
    - addEventListener()可以同时为一个元素的相同事件绑定多个响应函数
        当事件触发时响应函数会按照函数的绑定顺序执行，但不支持IE8及以下浏览器
- attachEvent()
    - 该方法可以为元素绑定响应函数
    - 参数：
        - 事件的字符串，要on
        - 回调函数
    - 该方法也可以同时为一个元素的相同事件绑定多个响应函数，支持IE8
        不同的是它是后绑定先执行，执行顺序和addEventListener()相反
- 事件的传播
    - 关于事件的传播网景公司和微软公司有不同的解释
    - 微软公司认为事件应该是由内向外传播的，也就是当事件触发时，先触发当前元素上的事件，
        然后再向当前元素的祖先元素上传播；而网景公司则认为元素事件的传播方式与微软公司的相反
    - W3C综合了两个公司的传播方案，将事件分为了三个阶段
        - 捕获阶段
            - 在捕获阶段时从最外层的祖先元素向目标元素进行事件的捕获，但是此时默认不会触发事件
        - 目标阶段
            - 事件捕获到目标元素，捕获结束开始在目标元素上触发事件
        - 冒泡阶段
            - 事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件
    - 如果希望在捕获阶段就触发事件，可以将addEventListener()中的第三个参数设置为true
    - IE8及以下的浏览器中没有捕获阶段</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/29/JavaScript/JavaScript%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-29
        
    </p>

    

    <!-- Content -->
    <p>超链接</p>
<pre><code>* 点击超链接之后会跳转页面，这个是超链接的默认行为，当我们不想跳转页面时，
    可以将超链接的 href 属性设置为javascript:;或者#，设置为javascript:;时，点击超链接不会有任何反应
        设置为#时，点击超链接时会返回顶部，在绑定事件时也可以在响应函数的最后return false，
            效果和javascript:;一样</code></pre>
<p>响应事件中的 for 循环</p>
<pre><code>* for循环在页面加载之后立即执行，而响应事件会在被触发时才执行</code></pre>
<p>兼容</p>
<pre><code>* 我们可以自己定义一个函数方法来兼容不同浏览器获取元素样式的方法
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">参数：</span><br><span class="line">    obj 要获取样式的元素</span><br><span class="line">    name 要获取的样式名</span><br><span class="line"> --&gt;</span><br><span class="line"> function getStyle(obj,name)&#123;</span><br><span class="line">     if(window,getComputedStyle)&#123;</span><br><span class="line">         &lt;!-- 正常浏览器的方法，具有getComputedStyle()方法 --&gt;</span><br><span class="line">         return getComputedStyle(obj,null)[name];</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         &lt;!-- IE8的方式，没有getComputedStyle()方法 --&gt;</span><br><span class="line">         return obj.currentStyle[name];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
* 定义一个函数方法来兼容不同浏览器的事件对象event
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event&#x3D;event||window.event;</span><br><span class="line">&lt;!-- 有则获取event，无则获取window.event --&gt;</span><br></pre></td></tr></table></figure>
* chrome认为浏览器的滚动条时body的，可以通过body来获取，而火狐等浏览器则认为是html的
    我们可以定义一个函数方法来兼容不同的获取方法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;document.body.scrollTop||document.documentElement.scrollTop;</span><br></pre></td></tr></table></figure>
* 定义一个函数方法来兼容不同浏览器为同一事件绑定多个响应函数的不同方法
```
&lt;!-- 
参数：
    - obj 要绑定事件的对象
    - evnetStr 事件的字符串
    - callback 回调函数
 --&gt;
 function bind(obj,eventStr,callback)&#123;
     if(obj.addEventListener)&#123;
         obj.addEventListener(eventStr,callback,false);
     &#125;else&#123;
         obj.attachEvent(&quot;on&quot;+eventStr,callback);
     &#125;
 &#125;
 &lt;!--
    addEventListener()中的this是绑定事件的对象，attachEvent()中的this是window，
        所以需要统一两个方法中的this，this是谁有调用方式决定:callback.call(obj)
            因此可以在匿名函数中调用回调函数
            obj.attachEvent(&quot;on&quot;+eventStr,function()&#123;
                callback.call(obj);
            &#125;);
 --&gt;</code></pre>
<p>表单</p>
<pre><code>* 如果为表单项添加disabled=&quot;disabled&quot; 则表单项将变成不可用的状态
    disabled属性可以设置一个元素是否禁用
        设置为true则元素禁用
        设置为false则元素可用</code></pre>
<p>拖拽</p>
<pre><code>* 当我们拖拽网页中的一个内容时，浏览器会默认去搜索引擎中搜索内容
    此时会导致拖拽功能的异常，这是浏览器提供的默认行为
        可以通过return false来取消默认行为，但此方法对IE8不起作用</code></pre>
<p>取消默认行为</p>
<pre><code>* 用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false
    需要使用event.preventDefault()方法来取消默认行为，但IE8不支持，若直接使用会报错
* 在文本框内输入内容，属于onkeydown的默认行为，若取消了该默认行为则输入的内容不会在文本框内显示</code></pre>
<p>滚轮</p>
<pre><code>* 当滚轮滚动时，若浏览器有滚动条则会随之滚动，这是浏览器的默认行为，可以取消</code></pre>
<p>定时器</p>
<pre><code>* 当我们将定时器绑定到一个按钮上时，我们每点击一次按钮就会开启一个定时器
    点击几次就会开启几个定时器，这会导致定时器所执行的函数间隔时间变的越来越短
        并且我们只能关闭最后一次开启的定时器，因此在开启定时器时，我们可以先将当前元素上的定时器关闭</code></pre>
<p>修改元素的样式</p>
<pre><code>* 通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面
    这样的执行性能是比较差的，而且这种形式当我们需要修改多个样式时也不太方便
        因此我们可以修改元素的类名或id，然后在css中的该类名中添加想要修改的样式
            这样一来，我们只需要修改一次即可同时修改多个样式，浏览器也只要重新渲染一次页面即可
                性能较好，并且这种方式可以使表现和行为进一步的分离</code></pre>
<p>函数</p>
<pre><code>* eval()
    - 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回
    - 如果使用该函数执行的字符串中含有&#123;&#125;,他会将其当作代码块
        若不希望将其当作代码块来处理则需要将字符串写入()中
    - 该函数功能十分强大，可以直接执行一个字符串中的JS代码，
        但在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/27/JavaScript/JavaScript08/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-27
        
    </p>

    

    <!-- Content -->
    <p>正则表达式</p>
<pre><code>* 正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式来检查一个字符串是否符合规则
    通过赋值给另一个变量可以将字符串中符合规则的内容提取出来
* 创建正则表达式
    - 使用构造函数创建，语法：var 变量=new RegExp(&quot;正则表达式&quot;,&quot;匹配模式&quot;);第二个参数可省略
    - 匹配模式可选值：
        - i 忽略大小写
        - g 全局匹配模式
    - 使用typeof检查正则表达式，会返回object
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg&#x3D;new RegExp(&quot;a&quot;);</span><br></pre></td></tr></table></figure>
    - 使用字面量创建，语法：var 变量=/正则表达式/匹配模式
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg&#x3D;&#x2F;a&#x2F;;</span><br></pre></td></tr></table></figure></code></pre>
<p>DOM</p>
<pre><code>* DOM，文档对象模型
    - 文档：表示的就是整个的HTML网页文档
    - 对象：表示将网页中的每一个部分都转换为了一个对象
    - 模型：使用模型来表示对象之间的关系
* 节点（Node），是构成我们网页的最基本的组成结构，网页中的每一个部分都可以称为是一个节点
    比如：HTML标签、属性、文本、注释、整个文档等都是一个节点
* 常用节点分为四类：
    - 文档节点：整个HTML文档
        - nodeName：#document
        - nodeType：9
        - nodeValue：null
    - 元素节点：HTML文档中的HTML标签
        - nodeName：标签名
        - nodeType：1
        - nodeValue：null
    - 属性节点：元素的属性
        - nodeName：属性名
        - nodeType：2
        - nodeValue：属性值
    - 文本节点：HTML标签中的文本内容
        - nodeName：#text
        - nodeType：3
        - nodeValue：文本内容
* 浏览器已经为我们提供了文档节点对象，这个对象就是window属性
    可以在网页中直接使用，文档节点表示整个网页
* 方法与属性：
    - getElementById() 通过id属性获取一个元素节点对象
    - getElementsByTagName() 通过标签名获取一组元素节点对象
        这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中，
            即使查询到的元素只有一个，也会封装到数组中返回
    - getElementsByName() 通过name属性获取一组元素节点对象
    - getElementsByClassName() 通过class属性获取一组元素节点对象，但不支持IE8及以下的浏览器
    - innerHTML 用于获取元素内部的HTML代码，可以将其和createElement()结合完成DOM的增删改的操作
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;document.createElement(&quot;li&quot;);</span><br><span class="line">li.innerHTML&#x3D;&quot;广州&quot;;</span><br></pre></td></tr></table></figure>
    - innerText 获取到元素内部的文本内容，和innerHTML不同的是它会自动将HTML标签除去
    - parentNode 该属性会获取指定节点的父节点
    - childNodes 该属性会获取包括文本节点在内的所有子节点，DOM标签与标签之间的空白也会被当成文本节点
        注意：在IE8及以下的浏览器中不会将空白文本当成子节点
    - children 该属性可以获取当前元素的所有子元素（即元素节点）
    - firstChild 获取当前元素的第一个子节点，该属性不支持IE8及以下的浏览器
    - firstElementChild 获取当前元素的第一个子元素
    - previousSibling 获取当前节点的前一个兄弟节点
    - previousElementSibling 获取当前节点的前一个元素节点
    - appendChild()，向一个父节点添加一个新的子节点，语法：父节点.appendChild(子节点);
    - insertBefore()，在指定的子节点之前插入新的子节点，语法：父节点.insertBefore(新节点，旧节点);
    - replaceChild()，使用指定的子节点代替已有的子节点，语法：父节点.replaceChild(新节点，旧节点);
    - removeChild()，删除一个子节点，语法：父节点.removeChild(子节点);
    - 若需要读取元素节点属性，直接使用元素.属性，如：元素.id  元素.name
        注意：class属性不能采用这种方式，读取class属性时需要使用元素.className
    - 在document中有一个属性body，它保存的是body的引用
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var body&#x3D;document.body;</span><br></pre></td></tr></table></figure>
    - document.documentElement保存的是html根标签
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var html&#x3D;document.documentElement;</span><br></pre></td></tr></table></figure>
    - document.all代表页面中的所有元素
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var all&#x3D;document.all;</span><br><span class="line">&lt;!-- all&#x3D;document.getElementsByTagName(&quot;*&quot;); --&gt;</span><br></pre></td></tr></table></figure>
    - document.querySelector()
        - 需要一个选择器的字符串作为参数，可以根据一个css选择器来查询一个元素节点对象
        - 虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替
        - 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var div&#x3D;document.querySelector(&quot;.box1 div&quot;);</span><br><span class="line">&lt;!-- 查询到class属性值为box1的元素中的div --&gt;</span><br></pre></td></tr></table></figure>
    - document.querySelectorAll()
        - 该方法和querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回
            即使符合条件的只有一个元素，它也会返回数组
    - document.createElement()
        - 创建一个元素节点对象，需要一个标签名以字符串的形式作为参数，会根据该标签名创建元素节点对象并返回
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;document.createElement(&quot;li&quot;);</span><br></pre></td></tr></table></figure>
    - document.createTextNode()
        - 创建一个文本节点对象，需要一个文本内容以字符串的形式作为参数，
            会根据该文本内容创建文本节点对象并返回
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;document.createTextNode(&quot;广州&quot;);</span><br></pre></td></tr></table></figure></code></pre>
<p>事件</p>
<pre><code>* 事件就是文档或是浏览器窗口发生的一些特定的交互瞬间，JavaScript与HTML之间交互是通过事件实现的
    比如：点击某个元素、将鼠标移动到某个元素上方等等
* 我们可以在事件对应的属性中设置一些js代码，当事件被触发时代码就会执行
    这种行为我们称之为结构和行为耦合，不方便维护
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick&#x3D;&quot;alert(&quot;haha&quot;);&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
* 可以为按钮的对应事件绑定处理函数的形式来响应事件，这样当事件被触发时，其对应的函数就会被调用
* 浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取一行就运行一行，
    如果将script标签写在页面的上边，在代码执行时页面还没加载，
        页面还没有加载DOM对象也没有加载，会导致DOM对象无法获取
* 有时script代码的位置会导致执行出错，处理方式：
    - onload事件会在整个页面加载完成之后再触发，因此为window绑定一个onload事件，
        该事件对应的响应函数会在页面加载完成后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕
            即script的入口函数
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onload&#x3D;function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    - 将js代码编写到页面的下部，就是为了可以在页面加载完毕后在执行js代码
    - confirm() 用于弹出一个带有确认和取消按钮的提示框
        需要一个字符串作为参数，该字符串会作为提示文字显示出来
            如果用户点击确认则返回true，点击取消则返回false
    - onscroll 该事件会在元素的滚动条滚动时触发</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/26/JavaScript/JavaScript07/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-26
        
    </p>

    

    <!-- Content -->
    <p>Date对象</p>
<pre><code>* 在JS中使用Date对象来表示一个时间
* 创建一个Date对象，如果直接使用构造函数来创建一个Date对象则会封装为当前代码执行的时间
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;new Date();</span><br></pre></td></tr></table></figure>
* 创建一个指定的时间对象，需要在构造函数中传递参数
    - 使用字符串作为参数传递时格式如下
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;new Date(&quot;2001&#x2F;10&#x2F;19 5:10:3&quot;);</span><br><span class="line">&lt;!-- &quot;年&#x2F;月&#x2F;日 小时:分:秒&quot;   注意中间有空格 --&gt;</span><br></pre></td></tr></table></figure>
    - 直接使用参数传递时格式如下
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;new Date(2001,10,19,5,10,3);</span><br><span class="line">&lt;!-- 年,月,日,小时,分,秒 --&gt;</span><br></pre></td></tr></table></figure>
* 方法：
    - getDate() 获取当前时间对象是几日
    - getDay() 获取当前时间对象是周几
        - 会返回一个0-6的值
            0表示周日
            1表示周一
            ....
    - getMonth() 获取当前时间对象的月份
        - 会返回一个0-11的值
            0表示1月
            1表示2月
            ....
    - getFullYear() 获取当前时间对象的年份
    - getTime() 获取当前对象的时间戳
        - 时间戳指的是从格林威治标准时间的1970年1月1日0时0分0秒到当前日期所花费的毫秒数（1秒=1000毫秒）
        - 计算机底层在保存时间时使用的都是时间戳
    - 获取当前的时间戳
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var time&#x3D;Date.now();</span><br></pre></td></tr></table></figure></code></pre>
<p>Math对象</p>
<pre><code>* Math和其它对象不一样，他不是一个构造函数，它属于一个工具类不用创建对象
    它里边封装了数学运算相关的属性和方法，如Math.PI表示圆周率
* 方法：
    - abs() 计算一个数的绝对值
    - Math.ceil() 对一个数进行向上取整，只要有小数位就进1，1向上取整还是1
    - Math.floor() 对一个数进行向下取整，小数部分会被舍去
    - Math.round() 对一个数进行四舍五入取整
    - Math.random() 可以生成一个0-1之间的随机数
        - 生成一个0-x之间的随机数：
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.round(Math.random()*x);</span><br></pre></td></tr></table></figure>
    - max() 获取多个数中的最大值
    - min() 获取多个数中的最小值
    - Math.pow(x,y) 返回x的y次幂
    - Math.sprt() 对一个数进行开方运算</code></pre>
<p>包装类</p>
<pre><code>* 三个包装类，可以将基本数据类型转换为对象
    - String()
        - 可以将基本数据类型转换为String对象
    - Number()
        - 可以将基本数据类型转换为Number对象
    - Boolean()
        - 可以将基本数据类型转换为Boolean对象
* 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象
    然后再调用对象的属性和方法，调用完后再将其转换为基本数据类型</code></pre>
<p>String对象</p>
<pre><code>* 字符串对象，在底层字符串都是以数组的形式保存的
* 方法：
    - charAt()
        - 返回字符串中指定位置的字符
        - 根据索引获取指定的字符
    - charCodeAt()
        - 获取指定位置字符的字符编码（Unicode编码）
    - String.formCharCode()
        - 根据字符编码去获取字符
    - concat()
        - 连接两个或多个字符串
    - indexOf()
        - 检索一个字符串中是否含有指定的内容
            若含有则会返回其第一次出现的索引，若没有找到则返回-1
        - 可以添加第二个参数，指定开始查找的位置
    - lastIndexOf()
        - 该方法和indexOf()一样，不同的是indexOf是从前往后找
            lastIndexOf()是从后往前找
    - slice()
        - 获取指定的字符串,不会影响到原字符串
        - 参数：
            第一个参数，表示开始位置的索引，包括开始索引       
            第二个参数，表示结束位置的索引，不包括结束索引
                第二个参数可以省略不写，此时会截取从开始索引往后的所有元素
            - 索引可以传递一个负值，如果传递一个负值则从后往前计算
                -1 倒数第一个
                -2 倒数第二个....
    - substring()
        - 获取指定的字符串，用法规则和slice()类似，不同的是这个方法不接收负值作为参数
            如果传递了一个负值则默认为0，而且它还可以自动调整参数的位置，
                如果第二个参数小于第一个参数则自动交换
    - substr()
        - 获取指定的字符串
        - 参数：
            第一个参数，表示开始位置的索引，包括开始索引       
            第二个参数，表示截取的长度
    - split()
        - 可以将一个字符串拆分为一个数组
        - 参数：需要一个字符串作为参数，将会根据该字符串去拆分数组，
                    如果传递一个空串作为参数，则会将每一个字符都拆分为数组中的一个元素
    - toUpperCase()
        - 将一个字符串转换为大写并返回
    - toLowerCase()
        - 将一个字符串转换为小写并返回</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/25/Css/Css17/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-25
        
    </p>

    

    <!-- Content -->
    <p>像素</p>
<pre><code>* 屏幕是由一个一个发光的小点构成，这一个一个的小点就是像素
    分辨率：1920 × 1080 说的就是屏幕中小点的数量
* 在前端开发中像素要分为两种情况讨论，CSS像素和物理像素
    - CSS像素，编写网页时我们所用的像素就是CSS像素，浏览器在显示网页时，
        需要将CSS像素转换为物理像素然后再呈现，一个CSS像素由几个物理像素显示由浏览器决定
            默认情况下在PC端，一个CSS像素 = 一个物理像素</code></pre>
<p>视口（viewport）</p>
<pre><code>* 视口就是屏幕中用来显示网页的区域
* 可以通过查看视口的大小来观察CSS像素和物理像素的比值
* 默认情况下：
    - 视口宽度 1920px （CSS像素）
            1920px （物理像素）
            此时，CSS像素和物理像素的比值为1 ：1
* 放大两倍的情况下：
    - 视口宽度 960px （CSS像素）
            1920px （物理像素）
            此时，CSS像素和物理像素的比值为1 ：2
    - 我们可以通过改变视口的大小来改变CSS像素和物理像素的比值
* 在不同的屏幕中，单位像素的大小是不一样的，单位像素越小屏幕越清晰
    24寸 1920 × 1080
    iPhone6 4.7寸 750 × 1334
    https://material.io/resources/devices/ （查询各种手机像素比的网站）
    - 默认情况下，移动端的网页都会将视口设置为980像素（CSS像素）
        以确保pc端网页可以在移动端正常访问，但如果网页的宽度超过980
            移动端的浏览器会自动对网页进行缩放以完整显示网页，但往往不会有一个好的用户体验
                为了解决这个问题，大部分网站都会专门为了移动端设计网页</code></pre>
<p>移动端的设计</p>
<pre><code>* 使用媒体查询
    - 语法：@media 媒体类型&#123;&#125;
    - 媒体类型：
        - all 所有设备
        - print 打印设备
        - screen 带屏幕的设备
        - speech 屏幕阅读器
    - 可以在媒体类型前添加一个only，表示只有
        only的使用主要是为了兼容一些老版本浏览器
* 响应式布局
    - 网页可以根据不同的设备或窗口大小显示出不同的效果
    - 使用响应式布局可以使一个网页适用于所有设备
    - 响应式布局的关键就是媒体查询
        通过媒体查询可以为不同的设备或设备不同的状态来分别设置样式
* 媒体特性
    - width 视口宽度
    - height 视口高度
    - min-width 视口的最小宽度（视口大于指定宽度时生效）
    - max-width 视口的最大宽度（视口小于指定宽度时生效）
* 断点：样式切换的分界点称之为断点
* 视口大小
    - 小于768（CSS像素）超小屏幕 max-width=768px
    - 大于768（CSS像素）小屏幕   min-width=768px
    - 大于992（CSS像素）中型屏幕   min-width=992px
    - 大于1200（CSS像素）小屏幕   min-width=1200px
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@media not screen and (min-width:500px) and (max-width:700px)&#123;</span><br><span class="line">    body&#123;</span><br><span class="line">        background-color:red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--</span><br><span class="line"> 该样式意思为带屏幕设备除了宽度在500px和700px之间时body为红色</span><br><span class="line">    not 除了</span><br><span class="line">    and 且</span><br><span class="line">    ,   或</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure></code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/25/Css/Css16/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-25
        
    </p>

    

    <!-- Content -->
    <p>flex</p>
<pre><code>* flex
    - 将元素的display属性设置为flex，则该元素为弹性容器，该元素的子元素为弹性元素
    - flex还可以作为属性来使用，它可以设置所有弹性元素的三个样式
        - flex 增长 缩减 基础
            - initial “flex：0 1 auto”（只缩减不增长）
            - auto “flex：1 1 auto”（既增长也缩减）
            - none “flex：0 0 auto”（弹性元素没有弹性）
* 主轴：弹性元素的排列方式为主轴
* 侧轴：与主轴垂直方向的为侧轴
* 属性：
    - flex-direction 指定容器中弹性元素的排列方式
        可选值：
            - row 默认值，弹性元素在容器中水平排列（自左向右）
                - 主轴 自左向右
            - row-reverse 弹性元素在容器中反向水平排列（自右向左）
                - 主轴 自右向左
            - column 弹性元素在容器中纵向排列（自上向下）
                - 主轴 自上向下
            - column 弹性元素在容器中反向纵向排列（自下向上）
                - 主轴 自下向上
    - flex-grow 指定弹性元素的伸展系数
        - 当父元素有多余空间时，子元素如何伸展
        - 父元素的剩余空间会按照比例分配
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex-grow:1;</span><br><span class="line">&lt;!-- 该弹性元素在父元素的剩余空间分配中占比例中的一份 --&gt;</span><br></pre></td></tr></table></figure>
    - flex-shrink 指定弹性元素的收缩系数
        - 当父元素的空间不足以收纳所有子元素时对子元素进行收缩
        - 子元素越大则该子元素收缩的越大
    - flex-wrap 设置弹性元素是否在弹性容器中自动换行
        可选值：
            - nowrap 默认值，元素不会自动换行
            - wrap 元素会沿着侧轴方向自动换行
            - wrap-reserve 元素会沿着侧轴反方向自动换行
    - flex-flow wrap和direction的简写属性，可同时设置这两个属性
    - flex-basis 指定的是元素在主轴上的基础长度
        - 如果主轴是横向的，则该值指定的是元素的宽度
        - 如果主轴是纵向的，则该值指定的是元素的高度
        - 默认值是auto，表示参考元素自身的高度或宽度
        - 如果传递了一个具体的数值，则以该值为准
    - order 决定弹性元素的排列顺序
    - justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列）
        可选值：
            - flex-start 元素沿着主轴起边排列
            - flex-end 元素沿着主轴终边排列
            - center 元素沿着主轴居中排列
            - space-around 空白均匀分到元素两侧
            - space-between 空白均匀分到元素间
            - space-evenly 空白均匀分到元素的单侧
    - align-items 元素在侧轴上如何对齐
        可选值：
            - stretch 默认值，将元素的长度设置为相同的值
            - flex-start 元素不会拉伸，沿着侧轴起边对齐
            - flex-end 元素不会拉伸，沿着侧轴终边对齐
            - center 居中对齐
            - baseline 基线对齐
    - align-content 侧轴空白空间的分布，可选值与justify-content一样
    - align-self 用来覆盖当前当前弹性元素上的align-items</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>


    <div class="main">
<div class="blog-post">
    <!-- Title -->
    
      <h1 class="blog-post-title">
        <a href="/2020/10/25/Css/Css15/">No-title</a>
      </h1>
    
    <!-- Date and Author -->
    <p class="blog-post-meta">
        2020-10-25
        
    </p>

    

    <!-- Content -->
    <p>变形</p>
<pre><code>* 变形就是指通过css来改变元素的形状或位置
    - 变形不会影响到页面的布局
    - transform用来设置元素的变形效果
        - 平移：
            - translateX() 沿着X轴方向平移
            - translateY() 沿着Y轴方向平移
            - translateZ() 沿着Z轴方向平移
                - Z轴平移，调整元素在Z轴上的位置，由于其属于立体效果（近大远小），
                    默认情况下网页是不支持透视的，如果想要看见效果，必须设置网页的视距
                        即perspective属性，将其设置在html（根元素）的样式中
            - 平移元素，百分比是相对于自身计算的
        - 旋转：通过旋转可以使元素沿着x、y或z轴旋转指定的角度
            - rotateX() 沿着X轴旋转
            - rotateY() 沿着Y轴旋转
            - rotateZ() 沿着Z轴旋转
            - 旋转时还可以通过backface-visibility属性来设置是否显示元素的背面
        - 3d变形效果
            - 若想要看到所设置的立体动态效果，需通过transform-style属性来设置其3d效果
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform-style:preserve-3d;</span><br></pre></td></tr></table></figure>
        - transform-origin（变形原点）
            - 默认值为center
            - 可自定设置原点
        - 对元素进行缩放的函数（倍数缩放）
            - scale() 双方向的缩放
            - scaleX() 水平方向的缩放
            - scaleY() 垂直方向的缩放</code></pre>
<p>变量</p>
<pre><code>* css也支持变量的设置
    - 变量的设置规范
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--color:red;</span><br></pre></td></tr></table></figure>
    - 引用变量时的语法规范
     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color:var(--color);</span><br></pre></td></tr></table></figure>
    - 设置变量可以帮助我们在做代码量较多的项目修改时更方便</code></pre>
<p>less</p>
<pre><code>* less是一门css的预处理语言
    - less是一个css的增强版，通过该预处理语言我们可以编写更少的代码实现更强大的样式</code></pre>

    <!-- Only display the Read More link if we are displaying an excerpt -->
    

    <hr />

    

    



</div>
</div>




<div id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
</div>



  </div>
  <!-- Footer -->
  <div id="footer">
  <div id="footer-social">
    
    
    
    
    
    
</div>

  <p id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
    主题 <a href="https://github.com/Suolawangzai/hexo-theme-nebula" target="_blank">nebula</a>
  </p>

  <div id="busuanzi">
    <span id="busuanzi_container_site_pv">
      &hearts;
    总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
  </div>
  <!--
  <div id="footer-info">
    &copy; 2020 戴超群<br>
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </div>
-->
</div>

  <!-- After footer scripts -->
  <!-- Disqus Comments -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/main.js"></script>


</body>

</html>
